<!DOCTYPE html>
<html>
<head>
  <title>Nokia Twin</title>
  <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
  <meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://unpkg.com/d3-regression@1.3.4/dist/d3-regression.min.js"></script>
  <script src="dictionary.js"></script>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
</head>

<style>
  #smallmultiples {
    height: 100vh
  }
</style>

<body>
  <div class="container-fluid">
    <div class="row">
      <div class="col">
        <div id="smallmultiples"></div>
      </div>
    </div>
  </div>
</body>

<script>
  'use strict'

  var multiWidth = 250
  var multiheight = 100
  var margin = 50
  var cols = ["China","UK","US","India"]
  var rows = ["rating_overall","rating_balance","rating_career","rating_culture","rating_comp","knowledge", "power", "respect", "trust", "social_support", "romance", "similarity", "identity", "fun", "conflict"]

  d3.csv('assets/nokia_glassdoor_scored.csv',
  d3.autoType)
  .then(function (data) {


    var parseTime = d3.timeParse("%Y-%m");
    data.forEach(review=> {
      // parse dates that were not recognized by autotype
      review.date = (typeof review.date === "string") ? parseTime(review.date) : review.date 

      //check dictionary for country
      if(review.location != null) {
        for (let i = 0; i < dictionary.length; i++) {
          let country = dictionary[i]
          if(country.arr.indexOf(review.location) != -1) {
            review.country = country.key
            continue;
          }
        }
      }

      //compute mean of data across different parts of the review
      ["knowledge", "power", "respect", "trust", "social_support", "romance", "similarity", "identity", "fun", "conflict"].forEach(current => {
        review[current] = 5* d3.mean( //multiply by 5 (because i'm lazy)
          Object.keys(review) //get all keys of review
          .filter(key => key.includes(current)) //check which one has the current quality 
          .map(x => review[x]) //map back to full review (more performant)
        );
      })
    })

    init(data)
    /*data.forEach(review => {
      if(review.country == null && review.location != null) console.log(review.location)
    })*/
  });

function findPosition(review) {
  var x, y;
  cols.forEach((r,i) => {if(review.country.includes(r)) x=margin+i*(multiWidth + margin)});
  rows.forEach((r,i) => {if(str.includes(r)) y=margin+i*(multiheight + margin)})
  return "translate("+x+","+y+")"
}

function parseCategories(data) {
  var dimensions = rows.map(x=> {return {key: x, data: []}})
  dimensions.forEach(dimension => {

    //just do everything
    dimension.data = d3.nest()
    .key(d=>d.country)
    .key(d=>d.date)
    .rollup(function(v) { return {
      count: v.length,
      total: d3.sum(v, function(d) { return d[dimension.key]; }),
      avg: d3.mean(v, function(d) { return d[dimension.key]; }),
      med: d3.median(v, function(d) { return d[dimension.key]; }),
      dev: d3.deviation(v, function(d) { return d[dimension.key]; }),
      max: d3.max(v, function(d) { return d[dimension.key]; }),
      min: d3.min(v, function(d) { return d[dimension.key]; })
    }})
    .entries(
      data
      .filter(x=> cols.indexOf(x.country) !== -1)
      //.sort((a,b)=>Date.parse(a.key)-Date.parse(b.key))
    )


    dimension.data.forEach(country => {
      country.values.sort((a,b)=>Date.parse(a.key) - Date.parse(b.key))
    })
  })

 
  return dimensions
}

function drawMultiples(dimensions, svg, scales) {

    var sm_row = svg.selectAll("g.row").data(dimensions).enter().append("g")
      .attr("class",d=>d.key)
      .attr("transform", (d,i) => "translate(250,"+(i*150+100)+")")

      sm_row.append("text").text(d=>d.key).attr("text-anchor","end")

    var smallSingle = sm_row.selectAll("g.col").data(d=>d.data).enter().append("g").attr("class",d=>d.key)
    smallSingle.attr("transform", (d,i)=>"translate("+i*300+",0)")
    smallSingle.append("g").attr("transform", "translate(0,"+multiheight+")").call(d3.axisBottom(scales.x).ticks(5))
    smallSingle.append("g").call(d3.axisLeft(scales.y).ticks(5))
    smallSingle.append("text").text(d=>d.key.replace("_"," ")).attr("x",10).attr("y",10).attr("font-size","10pt")

    var line = smallSingle.append("path").datum(d=>d.values)
    .attr("fill","none")
    //.attr("foo",d=>{console.log(d)})
    .attr("stroke","green")
    .attr("stroke","green")
    .attr("d",d3.line()
      .x(d=>scales.x(Date.parse(d.key)))
      .y(d=>scales.y(d.value.avg))
      .curve(d3.curveMonotoneX)
    )
    
    var confidence = smallSingle.append("path").datum(d=>d.values)
    .attr("fill-opacity",.4)
    .attr("fill","green")
    .attr("d",d3.area()
      .x(d=>{
        return scales.x(Date.parse(d.key))
      })
      .y0(d=>{
        let dev = (d.value.dev != null) ? d.value.dev : 0 //check for standard deviation (some don'T have it because n=1)
        return scales.y(d.value.avg+(dev/2)) 
      })
      .y1(d=>{
        let dev = (d.value.dev != null) ? d.value.dev : 0
        return scales.y(d.value.avg-(dev/2))
      })
      .curve(d3.curveMonotoneX)
    )

    const regression = d3.regressionLinear()
      .x(d =>{return scales.x(Date.parse(d.key))})
      .y(d =>{return scales.y(d.value.avg)})
      .domain([0, multiWidth]);

    var regLine = smallSingle.append("path").datum(d=>regression(d.values)).attr("d",d3.line()).attr("class","regLine").attr("stroke","black").style("stroke-dasharray", ("3, 3"))  

    var path = d3.line()
      .x((d,i)=> {
       return scales.x(Date.parse(d.key)) 
      })
      .y(d=> scales.y(d.value.med))
      .curve(d3.curveMonotoneX)

    var lines = smallSingle.append("g").attr("class","lines")
    lines.selectAll("path").data(dimensions).enter().append("path")
    .attr("class",d=>{return d.key})
    .attr("d",(d,i,nodes)=>{
      var current_dimension =  d3.select(nodes[i].parentNode.parentNode.parentNode).attr("class") //
      var current_country =  d3.select(nodes[i].parentNode.parentNode).attr("class")
      return path(d.data.find(x=>x.key == current_country).values) 
    })
    .attr("stroke","grey")
    .attr("stroke-width","grey")
    .attr("stroke-opacity",.1)
    .attr("fill","none")
}

function init(data) {

  var sm = d3.select("#smallmultiples")
  var svg = sm.append("svg")
    .attr("width",sm.node().getBoundingClientRect().width)
    .attr("height",2*margin+(multiheight + margin) * rows.length)

  var scales = {
    x: d3.scaleTime().domain(d3.extent(data, d => d.date)).range([0,multiWidth]),
    y: d3.scaleLinear().domain([0,5]).range([multiheight,0])
  }


  /*console.log(data)
  console.log(
    d3.nest()

    .key(d=>d.country)
    .key(d=>d.date)
    .rollup(function(v) { return {
      count: v.length,
      total: d3.sum(v, function(d) { return d[dimension.key]; }),
      avg: d3.mean(v, function(d) { return d[dimension.key]; }),
      med: d3.median(v, function(d) { return d[dimension.key]; }),
      dev: d3.deviation(v, function(d) { return d[dimension.key]; }),
      max: d3.max(v, function(d) { return d[dimension.key]; }),
      min: d3.min(v, function(d) { return d[dimension.key]; })
    }})
    .entries(data.filter(x=>
      (x.country == "China") ||
      (x.country == "UK") ||
      (x.country == "US") ||
      (x.country == "India") 
      )
    .sort((a,b)=>Date.parse(a.key)-Date.parse(b.key))
    )
    )*/

  console.log(data)
  var dimensions = parseCategories(data)
  console.log(dimensions)
  drawMultiples(dimensions, svg, scales)

}
  </script>
</html>






