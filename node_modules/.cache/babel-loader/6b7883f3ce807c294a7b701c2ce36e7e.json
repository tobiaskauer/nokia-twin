{"remainingRequest":"/Users/tk/GitHub/nokia-twin/twin-dashboard/node_modules/babel-loader/lib/index.js!/Users/tk/GitHub/nokia-twin/twin-dashboard/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/tk/GitHub/nokia-twin/twin-dashboard/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/tk/GitHub/nokia-twin/twin-dashboard/src/components/vis.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/tk/GitHub/nokia-twin/twin-dashboard/src/components/vis.vue","mtime":1595364069586},{"path":"/Users/tk/GitHub/nokia-twin/twin-dashboard/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/tk/GitHub/nokia-twin/twin-dashboard/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/tk/GitHub/nokia-twin/twin-dashboard/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/tk/GitHub/nokia-twin/twin-dashboard/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZXZlcnkiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmciOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvciI7Ci8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJzsgLy9pbXBvcnQgeyByZWdyZXNzaW9uTGluZWFyIH0gZnJvbSAnZDMtcmVncmVzc2lvbic7CgpleHBvcnQgZGVmYXVsdCB7CiAgY29tcHV0ZWQ6IHsKICAgIHN0eWxlOiBmdW5jdGlvbiBzdHlsZSgpIHsKICAgICAgcmV0dXJuIHsKICAgICAgICB3aWR0aDogMTAwMCwKICAgICAgICAvL1RPRE86IHNldCB0byB3aW5kb3cgd2lkdGgKICAgICAgICBoZWlnaHQ6IDIwMCwKICAgICAgICBtYXJnaW46IHsKICAgICAgICAgIHRvcDogMjUsCiAgICAgICAgICByaWdodDogMjUsCiAgICAgICAgICBib3R0b206IDAsCiAgICAgICAgICBsZWZ0OiA0MAogICAgICAgIH0KICAgICAgfTsKICAgIH0sCiAgICBjb250ZXh0OiB7CiAgICAgIC8vZ2V0IGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gZnJvbSBzdG9yZQogICAgICBjYWNoZTogZmFsc2UsCiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgIHZhciBfdGhpcyA9IHRoaXM7CgogICAgICAgIHZhciBwYXJzZVRpbWUgPSBkMy50aW1lUGFyc2UoIiVZLSVtIik7CiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRDb250ZXh0Lm1hcChmdW5jdGlvbiAoaXRlbSkgewogICAgICAgICAgaXRlbS54ID0gX3RoaXMuc2NhbGVzLngocGFyc2VUaW1lKGl0ZW0uZGF0ZSkpOyAvL3RyYW5zbGF0ZSBkYXRlIHRvIHBvc2l0aW9uCgogICAgICAgICAgcmV0dXJuIGl0ZW07CiAgICAgICAgfSk7CiAgICAgICAgcmV0dXJuIGl0ZW1zOwogICAgICB9CiAgICB9LAogICAgZGF0YTogewogICAgICAvL2dldCBkYXRhIGZyb20gc3RvcmUKICAgICAgY2FjaGU6IGZhbHNlLAogICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRMaW5lcy5tYXAoZnVuY3Rpb24gKGxpbmUpIHsKICAgICAgICAgIGxpbmUudG91Y2hlZCA9IDA7IC8vYWRkIGNvdW50ZXIgZm9yIHJlYWN0aXZpdHkgd2hlbiB1c2luZyBicnVzaCBmdW5jdGlvbgoKICAgICAgICAgIHJldHVybiBsaW5lOwogICAgICAgIH0pOwogICAgICB9CiAgICB9LAogICAgZGF0YVN0YXRlOiBmdW5jdGlvbiBkYXRhU3RhdGUoKSB7CiAgICAgIC8vY2hlY2sgaWYgZXZlcnkgbGluZSB3ZSByZWNlaXZlZCBhbHNvIGhhcyBkYXRhIHZhbHVlcyBiZWZvcmUgd2UgcmVuZGVyCiAgICAgIHZhciBzdGF0ZSA9IGZhbHNlOyAvL2FzdW1lIHRoYXQgY29uZGl0aW9uIGlzIG5vdCBtZXQKCiAgICAgIHZhciBoYXNEYXRhID0gdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAobGluZSkgewogICAgICAgIHJldHVybiBsaW5lLnZhbHVlcyA/IHRydWUgOiBmYWxzZTsKICAgICAgfSk7IC8vY2hlY2sgaWYgdmFsdWUgYXJyYXkgZXhpc3RzCgogICAgICBpZiAoaGFzRGF0YS5sZW5ndGggPiAwICYmIGhhc0RhdGEuZXZlcnkoZnVuY3Rpb24gKGJvb2wpIHsKICAgICAgICByZXR1cm4gYm9vbDsKICAgICAgfSkpIHN0YXRlID0gdHJ1ZTsgLy9jaGVjayBpZiBhbGwgbGluZXMgaGF2ZSBkYXRhIChhbmQgaWYgd2UgaGF2ZSBsaW5lcyBhdCBhbGwsIG90aGVyd2lzZSBjb25kaXRpb24gZm9yIGV2ZXJ5KCkgd291bGQgYmUgdHJ1ZSkKCiAgICAgIHJldHVybiBzdGF0ZTsKICAgIH0sCiAgICBzY2FsZXM6IHsKICAgICAgLy9jb21wdXRlIHNjYWxlcwogICAgICBjYWNoZTogdHJ1ZSwKICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgdmFyIHBhcnNlVGltZSA9IGQzLnRpbWVQYXJzZSgiJVktJW0iKTsKICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlOwogICAgICAgIHZhciB3aWR0aCA9IGQzLnNjYWxlTGluZWFyKCkucmFuZ2UoWzIsIDZdKTsKICAgICAgICB2YXIgeCA9IGQzLnNjYWxlVGltZSgpLnJhbmdlKFtzdHlsZS5tYXJnaW4ubGVmdCwgc3R5bGUud2lkdGggLSBzdHlsZS5tYXJnaW4ubGVmdCAtIHN0eWxlLm1hcmdpbi5yaWdodF0pOwogICAgICAgIHZhciB5ID0gZDMuc2NhbGVMaW5lYXIoKS5yYW5nZShbc3R5bGUuaGVpZ2h0IC0gc3R5bGUubWFyZ2luLnRvcCAtIHN0eWxlLm1hcmdpbi5ib3R0b20sIHN0eWxlLm1hcmdpbi5ib3R0b21dKTsKICAgICAgICB2YXIgbWljcm9ZID0gZDMuc2NhbGVMaW5lYXIoKS5yYW5nZShbNDUsIDVdKTsKICAgICAgICB2YXIgbWljcm9YID0gZDMuc2NhbGVMaW5lYXIoKS5yYW5nZShbc3R5bGUubWFyZ2luLmxlZnQsIHN0eWxlLndpZHRoIC0gc3R5bGUubWFyZ2luLmxlZnQgLSBzdHlsZS5tYXJnaW4ucmlnaHRdKTsKICAgICAgICBkMy5heGlzTGVmdCgpLnNjYWxlKHgpOwogICAgICAgIGQzLmF4aXNCb3R0b20oKS5zY2FsZSh5KTsKCiAgICAgICAgaWYgKHRoaXMuZGF0YVN0YXRlKSB7CiAgICAgICAgICB2YXIgYXJyID0gW107IC8vbm90IGVsZWdhbnQsIGJ1dCBlYXNpZXN0IHdheSB0byBmaW5kIGV4dHJlbWUgdmFsdWVzIGFjcm9zcyBhbGwgbGluZXMKCiAgICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAobGluZSkgewogICAgICAgICAgICBsaW5lLnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkgewogICAgICAgICAgICAgIGFyci5wdXNoKHZhbHVlKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9KTsKICAgICAgICAgIHZhciBkb21haW4gPSB0aGlzLnhEb21haW4ubGVuZ3RoID4gMCA/IHRoaXMueERvbWFpbiA6IGQzLmV4dGVudChhcnIsIGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICAgIHJldHVybiBwYXJzZVRpbWUoZC5kKTsKICAgICAgICAgIH0pOyAvL2lmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUsIGdldCBhIHRoZSB4RG9tYWluIGZyb20gZGF0YSwgb3RoZXJ3aXNlIGl0IGhhcyBiZWVuIHNldCBieSB0aGUgYnJ1c2gKCiAgICAgICAgICB4LmRvbWFpbihkb21haW4pOwogICAgICAgICAgbWljcm9YLmRvbWFpbihkMy5leHRlbnQoYXJyLCBmdW5jdGlvbiAoZCkgewogICAgICAgICAgICByZXR1cm4gcGFyc2VUaW1lKGQuZCk7CiAgICAgICAgICB9KSk7IC8vZGVmaW5pdGVseSBzZXQgdGhpcyB0byB0aGUgbWF4aW11bSBkYXRhIGRvbWFpbiBzbyB3ZSBjYW4gcHVzaCBpdCB0byB0aGUgbGltaXQKCiAgICAgICAgICB5LmRvbWFpbihkMy5leHRlbnQoYXJyLCBmdW5jdGlvbiAoZCkgewogICAgICAgICAgICByZXR1cm4gK2QucjsKICAgICAgICAgIH0pKTsKICAgICAgICAgIG1pY3JvWS5kb21haW4oZDMuZXh0ZW50KGFyciwgZnVuY3Rpb24gKGQpIHsKICAgICAgICAgICAgcmV0dXJuICtkLnI7CiAgICAgICAgICB9KSk7CiAgICAgICAgICB3aWR0aC5kb21haW4oZDMuZXh0ZW50KGFyciwgZnVuY3Rpb24gKGQpIHsKICAgICAgICAgICAgcmV0dXJuICtkLmM7CiAgICAgICAgICB9KSk7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gewogICAgICAgICAgeDogeCwKICAgICAgICAgIHk6IHksCiAgICAgICAgICBtaWNyb1g6IG1pY3JvWCwKICAgICAgICAgIG1pY3JvWTogbWljcm9ZLAogICAgICAgICAgd2lkdGg6IHdpZHRoCiAgICAgICAgfTsKICAgICAgfQogICAgfSwKCiAgICAvKmxlZ2VuZDogewogICAgICBjYWNoZTogdHJ1ZSwKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICAgY29uc3QgcGF0aCA9IGQzLmFyZWEoKQogICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZUJhc2lzKQogICAgICAgIC54KGQgPT4gZC54KQogICAgICAgIC55MChkID0+IGQueTApCiAgICAgICAgLnkxKGQgPT4gZC55MSk7CiAgICAgICAgIHJldHVybiBwYXRoKFsKICAgICAgICAgIHt4OjEsIHkwOjEsIHkxOjF9LAogICAgICAgICAge3g6MTAsIHkwOjEwLCB5MToxMH0KICAgICAgICBdKQogICAgICB9CiAgICB9LCovCiAgICBsaW5lczogewogICAgICBjYWNoZTogZmFsc2UsCiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgIHZhciBfdGhpczIgPSB0aGlzOwoKICAgICAgICB2YXIgcGFyc2VUaW1lID0gZDMudGltZVBhcnNlKCIlWS0lbSIpOwogICAgICAgIHZhciBwYXRoID0gZDMuYXJlYSgpIC8vLmN1cnZlKGQzLmN1cnZlTmF0dXJhbCkKICAgICAgICAuY3VydmUoZDMuY3VydmVCYXNpcykueChmdW5jdGlvbiAoZCkgewogICAgICAgICAgcmV0dXJuIF90aGlzMi5zY2FsZXMueChwYXJzZVRpbWUoZC5kKSk7CiAgICAgICAgfSkueTAoZnVuY3Rpb24gKGQpIHsKICAgICAgICAgIHJldHVybiBfdGhpczIuc2NhbGVzLnkoZC5yKSAtIF90aGlzMi5zY2FsZXMud2lkdGgoZC5jKTsKICAgICAgICB9KS55MShmdW5jdGlvbiAoZCkgewogICAgICAgICAgcmV0dXJuIF90aGlzMi5zY2FsZXMueShkLnIpICsgX3RoaXMyLnNjYWxlcy53aWR0aChkLmMpOwogICAgICAgIH0pOwogICAgICAgIHZhciBtaWNybyA9IGQzLmxpbmUoKS5jdXJ2ZShkMy5jdXJ2ZUJhc2lzKS54KGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICByZXR1cm4gX3RoaXMyLnNjYWxlcy5taWNyb1gocGFyc2VUaW1lKGQuZCkpOwogICAgICAgIH0pLnkoZnVuY3Rpb24gKGQpIHsKICAgICAgICAgIHJldHVybiBfdGhpczIuc2NhbGVzLm1pY3JvWShkLnIpOwogICAgICAgIH0pOwogICAgICAgIHJldHVybiB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChsaW5lKSB7CiAgICAgICAgICBpZiAobGluZS52YWx1ZXMpIHsKICAgICAgICAgICAgbGluZS5wYXRoID0gcGF0aChsaW5lLnZhbHVlcyk7CiAgICAgICAgICAgIGxpbmUubWljcm8gPSBtaWNybyhsaW5lLnZhbHVlcyk7CiAgICAgICAgICB9IC8vaWYobGluZS52YWx1ZXMpIGxpbmUucmVnTGluZSA9IHJlZyhsaW5lLnZhbHVlcykKCgogICAgICAgICAgcmV0dXJuIGxpbmU7CiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0KICB9LAogIGRpcmVjdGl2ZXM6IHsKICAgIGF4aXM6IGZ1bmN0aW9uIGF4aXMoZWwsIGJpbmRpbmcpIHsKICAgICAgLy9keW5hbWljYWxseSBjYWxsIGFuZCB1cGRhdGUgYXhpcwogICAgICAvL2xldCBwYXJzZVRpbWUgPSBkMy50aW1lUGFyc2UoIiVZLSVtIik7CiAgICAgIHZhciBheGlzID0gYmluZGluZy5hcmc7CiAgICAgIHZhciBheGlzTWV0aG9kID0gewogICAgICAgIHg6ICJheGlzQm90dG9tIiwKICAgICAgICB5OiAiYXhpc0xlZnQiCiAgICAgIH1bYXhpc107CiAgICAgIHZhciBtZXRob2RBcmcgPSBiaW5kaW5nLnZhbHVlW2F4aXNdOwogICAgICBkMy5zZWxlY3QoZWwpLnRyYW5zaXRpb24oKS5jYWxsKGQzW2F4aXNNZXRob2RdKG1ldGhvZEFyZykudGlja3MoNSkpOwogICAgfQogICAgLypicnVzaChlbCwgYmluZGluZykgewogICAgICBsZXQgc2NhbGVzID0gYmluZGluZy52YWx1ZQogICAgICBjb25zdCBicnVzaCA9IGQzLmJydXNoWCgpCiAgICAgICAgLmV4dGVudChzY2FsZXMubWljcm9YLnJhbmdlKCkubWFwKChlLGkpID0+IFtlLGkqNTBdKSkKICAgICAgICAub24oInN0YXJ0IGJydXNoIiwgdXBkYXRlWCkKICAgICAgIGQzLnNlbGVjdChlbCkuY2FsbChicnVzaCkuY2FsbChicnVzaC5tb3ZlLCBzY2FsZXMueC5yYW5nZSgpKQogICAgfSovCgogIH0sCiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHsKICAgIGlmICh0aGlzLmRhdGFTdGF0ZSkgdGhpcy5icnVzaCgpOwogIH0sCiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHsKICAgIHJldHVybiB7CiAgICAgIHNob3dDb250ZXh0OiB0cnVlLAogICAgICB4RG9tYWluOiBbXQogICAgfTsKICB9LAogIG1ldGhvZHM6IHsKICAgIGJydXNoOiBmdW5jdGlvbiBicnVzaCgpIHsKICAgICAgdmFyIGJydXNoID0gZDMuYnJ1c2hYKCkuZXh0ZW50KHRoaXMuc2NhbGVzLm1pY3JvWC5yYW5nZSgpLm1hcChmdW5jdGlvbiAoZSwgaSkgewogICAgICAgIHJldHVybiBbZSwgaSAqIDUwXTsKICAgICAgfSkpLm9uKCJzdGFydCBicnVzaCIsIHRoaXMudXBkYXRlWCk7CiAgICAgIGQzLnNlbGVjdCgiZy5icnVzaCIpLmNhbGwoYnJ1c2gpLmNhbGwoYnJ1c2gubW92ZSwgdGhpcy5zY2FsZXMueC5yYW5nZSgpKTsKICAgIH0sCiAgICB1cGRhdGVYOiBmdW5jdGlvbiB1cGRhdGVYKCkgewogICAgICB2YXIgX3RoaXMzID0gdGhpczsKCiAgICAgIC8vVE9ETyBkb21haW4gc2VlbXMgdG8gd29yaywgYnV0IHVzZXMgaW5leGljYWJseSBoaWdoIHZhbHVlcwogICAgICB2YXIgZG9tYWluID0gZDMuZXZlbnQuc2VsZWN0aW9uLm1hcChmdW5jdGlvbiAodmFsdWUpIHsKICAgICAgICByZXR1cm4gX3RoaXMzLnNjYWxlcy5taWNyb1guaW52ZXJ0KHZhbHVlKTsKICAgICAgfSk7IC8vZ2V0IG5ldyBkb21haW4gYnkgZ2V0dGluZyBlZGdlcyBvZiBvdmVybGF5IGFuZCB0cmFuc2xhdGUgdGhlbSB0byBkYXRlcwoKICAgICAgZG9tYWluLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpKSB7CiAgICAgICAgY29uc29sZS5sb2codmFsdWUsIGkpOyAvLyAgdGhpcy4kc2V0KHRoaXMueERvbWFpbixpLHZhbHVlKSAvL2l0ZXJhdGUgb3ZlciB0aGlzIGFycmF5IHRvIHRyaWdnZXIgcmVhY3Rpdml0eQogICAgICB9KTsKICAgICAgZDMuc2VsZWN0KCIueEF4ZXMiKS50cmFuc2l0aW9uKCkuY2FsbChkMy5heGlzQm90dG9tKHRoaXMuc2NhbGVzLngpKTsgLy91cGRhdGUgQXhpcwogICAgfQogIH0KICAvKnByb3BzOiB7CiAgfSwKICAKICBjcmVhdGVkICgpIHsKICB9LAogICBtZXRob2RzOiB7CiAgfSwqLwoKfTs="},{"version":3,"sources":["vis.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n  <div class=\"col-9\">\n    <!--<div v-if=\"dataState\">\n      <div v-for=\"(line,index) in lines\" v-bind:key=\"index\">{{line.query}}</div>\n    </div>-->\n    <svg :width=\"style.width\" :height=\"style.height\" v-if=\"dataState\" class=\"lines\">\n      <g class=\"axes\">\n        <g v-axis:x=\"scales\" class=\"xAxes\" :transform=\"`translate(0,${style.height-style.margin.top-style.margin.bottom})`\"></g>\n        <g v-axis:y=\"scales\" class=\"yAxes\" :transform=\"`translate(${style.margin.left},0)`\"></g>\n      </g>\n      <g class=\"context\" v-if=\"showContext\">\n        <g v-for=\"(item, index) in context\" :key=\"`context-${index}`\" :transform=\"`translate(${item.x},0)`\">\n          <line x1=\"0\" x2=\"0\" :y1=\"style.margin.top\" :y2=\"style.height-style.margin.bottom-style.margin.top\" stroke=\"black\" stroke-dasharray=\"4\" />\n          <text x=\"10\" :y=\"style.margin.top+20\">{{item.text}}</text>\n        </g>\n      </g>\n      <!--<g class=\"legend\" :transform=\"`translate(${style.width-style.margin.right-200},100)`\">\n        <path :d=\"legend\" fill=\"black\"/>\n      </g>-->\n      <g class=\"lines\" v-for=\"line in lines\" v-bind:key=\"line.identifier\">\n        <path v-if=\"line.path\" :d=\"line.path\" :fill=\"line.color\" stroke=\"none\"/>\n      </g>\n    </svg>\n\n    <svg :width=\"style.width\" height=\"50\" v-if=\"dataState\" style=\"background-color: lightgrey\">\n      <g class=\"lines\" v-for=\"line in lines\" v-bind:key=\"line.identifier\" >\n        <path v-if=\"line.micro\" :d=\"line.micro\" :stroke=\"line.color\" stroke-opacity=\"0.5\" fill=\"none\"/>\n      </g>\n      <g class=\"brush\" />\n    </svg>\n\n\n    <form>\n      <div class=\"form-check\">\n        <input type=\"checkbox\" class=\"form-check-input\" id=\"exampleCheck1\" v-model=\"showContext\" @click=\"showContext = !showContext\">\n        <label class=\"form-check-label\" for=\"exampleCheck1\">Show context</label>\n      </div>\n    </form>\n  </div>\n</template>\n\n<script>\nimport * as d3 from 'd3'\n//import { regressionLinear } from 'd3-regression';\n\n\nexport default {\n  computed: {\n    style: function() {\n      return {\n        width: 1000, //TODO: set to window width\n        height: 200,\n        margin: {\n          top: 25,\n          right: 25,\n          bottom: 0 ,\n          left: 40\n        }\n      }\n    },\n\n    context: { //get additional information from store\n      cache: false,\n      get: function() {\n        let parseTime = d3.timeParse(\"%Y-%m\");\n        let items = this.$store.getters.getContext.map(item => {\n          item.x = this.scales.x(parseTime(item.date)) //translate date to position\n          return item\n        })\n        return items\n      }\n    },\n\n\n    data: { //get data from store\n      cache: false,\n      get: function() {\n        return this.$store.getters.getLines.map(line => {\n          line.touched = 0 //add counter for reactivity when using brush function\n          return line\n        })\n      }\n    },\n\n    dataState: function() { //check if every line we received also has data values before we render\n      let state = false //asume that condition is not met\n      let hasData = this.data.map(line => (line.values) ? true : false) //check if value array exists\n      if(hasData.length > 0 && hasData.every(bool => bool)) state = true //check if all lines have data (and if we have lines at all, otherwise condition for every() would be true)\n      return state\n    },\n\n    scales: {//compute scales\n      cache: true,\n      get() {\n        let parseTime = d3.timeParse(\"%Y-%m\");\n        let style = this.style\n\n        const width = d3.scaleLinear().range([2,6])\n        const x = d3.scaleTime().range([style.margin.left,style.width - style.margin.left - style.margin.right]);\n        const y = d3.scaleLinear().range([\n          style.height - style.margin.top - style.margin.bottom,\n          style.margin.bottom\n        ]);\n        const microY = d3.scaleLinear().range([45,5]);\n        const microX = d3.scaleLinear().range([style.margin.left,style.width - style.margin.left - style.margin.right]);\n\n        d3.axisLeft().scale(x);\n        d3.axisBottom().scale(y);\n\n        if(this.dataState) {\n          let arr = [] //not elegant, but easiest way to find extreme values across all lines\n          this.data.forEach(line => {\n            line.values.forEach(value => {\n              arr.push(value)\n            })\n          })\n\n          let domain = (this.xDomain.length > 0) ? this.xDomain : d3.extent(arr, d => parseTime(d.d)) //if this is the first time, get a the xDomain from data, otherwise it has been set by the brush\n\n          x.domain(domain);\n          microX.domain(d3.extent(arr, d => parseTime(d.d))); //definitely set this to the maximum data domain so we can push it to the limit\n          y.domain(d3.extent(arr, d => +d.r));\n          microY.domain(d3.extent(arr, d => +d.r));\n          width.domain(d3.extent(arr, d => +d.c))\n        }\n\n        return { x, y, microX, microY, width };\n      }\n    },\n\n    /*legend: {\n      cache: true,\n      get: function() {\n\n        const path = d3.area()\n        .curve(d3.curveBasis)\n        .x(d => d.x)\n        .y0(d => d.y0)\n        .y1(d => d.y1);\n\n        return path([\n          {x:1, y0:1, y1:1},\n          {x:10, y0:10, y1:10}\n        ])\n      }\n    },*/\n\n\n\n    lines: {\n      cache: false,\n      get: function() {\n        let parseTime = d3.timeParse(\"%Y-%m\");\n         const path = d3.area()\n         //.curve(d3.curveNatural)\n         .curve(d3.curveBasis)\n         .x(d => this.scales.x(parseTime(d.d)))\n         .y0(d => this.scales.y(d.r)-this.scales.width(d.c))\n         .y1(d => this.scales.y(d.r)+this.scales.width(d.c));\n\n         const micro = d3.line()\n         .curve(d3.curveBasis)\n         .x(d => this.scales.microX(parseTime(d.d)))\n         .y(d => this.scales.microY(d.r));\n\n         return this.data.map(line => {\n           if(line.values) {\n             line.path = path(line.values)\n             line.micro = micro(line.values)\n           }\n           //if(line.values) line.regLine = reg(line.values)\n           return line\n         })\n      }\n    },\n  },\n\n  directives: {\n    axis(el, binding) {//dynamically call and update axis\n\n      //let parseTime = d3.timeParse(\"%Y-%m\");\n      const axis = binding.arg;\n      const axisMethod = { x: \"axisBottom\", y: \"axisLeft\" }[axis];\n      const methodArg = binding.value[axis];\n      d3.select(el).transition().call(d3[axisMethod](methodArg).ticks(5));\n    },\n\n    /*brush(el, binding) {\n      let scales = binding.value\n      const brush = d3.brushX()\n        .extent(scales.microX.range().map((e,i) => [e,i*50]))\n        .on(\"start brush\", updateX)\n\n      d3.select(el).call(brush).call(brush.move, scales.x.range())\n    }*/\n  },\n\n\n\n  mounted () {\n    if(this.dataState) this.brush()\n  },\n\n  data() {\n    return {\n      showContext: true,\n      xDomain: []\n    }\n  },\n\n  methods: {\n    brush: function() {\n      const brush = d3.brushX()\n        .extent(this.scales.microX.range().map((e,i) => [e,i*50]))\n        .on(\"start brush\", this.updateX)\n\n      d3.select(\"g.brush\")\n        .call(brush)\n        .call(brush.move, this.scales.x.range())\n    },\n    updateX: function() {\n      //TODO domain seems to work, but uses inexicably high values\n      let domain = d3.event.selection.map(value => this.scales.microX.invert(value)) //get new domain by getting edges of overlay and translate them to dates\n      domain.forEach((value,i) => {\n        console.log(value,i)\n      //  this.$set(this.xDomain,i,value) //iterate over this array to trigger reactivity\n      })\n\n\n      d3.select(\".xAxes\").transition().call(d3.axisBottom(this.scales.x)) //update Axis\n\n    }\n  }\n\n  /*props: {\n  },\n\n\n\n  created () {\n  },\n\n  methods: {\n  },*/\n}\n</script>\n\n<style scoped>\ndiv {\n  background-color: #F7F7F7;\n}\nsvg.lines {\n  margin-top: 50px;\n  background-color: white;\n}\npath {\n  transition: d .3s\n}\n\n.context text {\n  font-size: 10px;\n}\n</style>\n"],"sourceRoot":"src/components"}]}