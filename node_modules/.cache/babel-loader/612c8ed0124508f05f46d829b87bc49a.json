{"remainingRequest":"/Users/tk/GitHub/nokiatwin/node_modules/babel-loader/lib/index.js!/Users/tk/GitHub/nokiatwin/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/tk/GitHub/nokiatwin/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/tk/GitHub/nokiatwin/src/components/vis.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/tk/GitHub/nokiatwin/src/components/vis.vue","mtime":1606847040784},{"path":"/Users/tk/GitHub/nokiatwin/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/tk/GitHub/nokiatwin/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/tk/GitHub/nokiatwin/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/tk/GitHub/nokiatwin/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZXZlcnkiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmciOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvciI7Ci8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJzsKaW1wb3J0IHsgVnVlRGF0ZVBpY2tlciB9IGZyb20gJ0BtYXRoaWV1c3Rhbi92dWUtZGF0ZXBpY2tlcic7CmltcG9ydCAnQG1hdGhpZXVzdGFuL3Z1ZS1kYXRlcGlja2VyL2Rpc3QvdnVlLWRhdGVwaWNrZXIubWluLmNzcyc7CmV4cG9ydCBkZWZhdWx0IHsKICBjb21wb25lbnRzOiB7CiAgICBWdWVEYXRlUGlja2VyOiBWdWVEYXRlUGlja2VyCiAgfSwKICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkgewogICAgcmV0dXJuIHsKICAgICAgc2hvd0V2ZW50czogdHJ1ZSwKICAgICAgY3VycmVudEV2ZW50OiB7fSwKICAgICAgeERvbWFpbjogW10sCiAgICAgIGRhdGVQaWNrZXI6IFtdLAogICAgICAvL2VtcHR5IGFycmF5IHRvIHBhc3MgZGF0ZXMgYmV0d2VlbiBkYXRlcGlja2VyIGFuZCBzY2FsZXMKICAgICAgYnJ1c2g6IG51bGwsCiAgICAgIGxpbmVUaGlja25lc3M6IFszLCA3XSwKICAgICAgc3R5bGU6IHsKICAgICAgICB3aWR0aDogMTAwMCwKICAgICAgICAvL1RPRE86IHNldCB0byB3aW5kb3cgd2lkdGgKICAgICAgICBoZWlnaHQ6IDMwMCwKICAgICAgICBtYXJnaW46IHsKICAgICAgICAgIHRvcDogMzAsCiAgICAgICAgICByaWdodDogMjUsCiAgICAgICAgICBib3R0b206IDAsCiAgICAgICAgICBsZWZ0OiA0MAogICAgICAgIH0KICAgICAgfQogICAgfTsKICB9LAogIGNvbXB1dGVkOiB7CiAgICBldmVudHM6IHsKICAgICAgLy9nZXQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBmcm9tIHN0b3JlCiAgICAgIGNhY2hlOiB0cnVlLAogICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICB2YXIgX3RoaXMgPSB0aGlzOwoKICAgICAgICB2YXIgcGFyc2VUaW1lID0gZDMudGltZVBhcnNlKCIlZC0lbS0lWSIpOwogICAgICAgIHZhciBldmVudHMgPSB0aGlzLiRzdG9yZS5zdGF0ZS5ldmVudHMubWFwKGZ1bmN0aW9uIChldmVudCkgewogICAgICAgICAgZXZlbnQueCA9IF90aGlzLnNjYWxlcy54KHBhcnNlVGltZShldmVudC5kYXRlKSk7IC8vdHJhbnNsYXRlIGRhdGUgdG8gcG9zaXRpb24KCiAgICAgICAgICByZXR1cm4gZXZlbnQ7CiAgICAgICAgfSk7CiAgICAgICAgcmV0dXJuIGV2ZW50czsKICAgICAgfQogICAgfSwKICAgIGFjdGl2ZU1ldHJpYzogZnVuY3Rpb24gYWN0aXZlTWV0cmljKCkgewogICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRBY3RpdmVNZXRyaWM7CiAgICB9LAogICAgLy9nZXQgZGF0YSBmcm9tIHN0b3JlICh0aGlzIGlzIHRoZSBjb21wdXRlZCBwcm9wZXJ0eSAiZGF0YSIsIG5vdCB2dWUncyBkYXRhIHByb3BlcnR5KQogICAgZGF0YTogewogICAgICBjYWNoZTogZmFsc2UsCiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldExpbmVzLm1hcChmdW5jdGlvbiAobGluZSkgewogICAgICAgICAgbGluZS50b3VjaGVkID0gMDsgLy9hZGQgY291bnRlciBmb3IgcmVhY3Rpdml0eSB3aGVuIHVzaW5nIGJydXNoIGZ1bmN0aW9uCgogICAgICAgICAgcmV0dXJuIGxpbmU7CiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0sCiAgICAvL2NoZWNrIGlmIGV2ZXJ5IGxpbmUgd2UgcmVjZWl2ZWQgYWxzbyBoYXMgZGF0YSB2YWx1ZXMgYmVmb3JlIHdlIHJlbmRlcgogICAgZGF0YVN0YXRlOiBmdW5jdGlvbiBkYXRhU3RhdGUoKSB7CiAgICAgIHZhciBzdGF0ZSA9IGZhbHNlOyAvL2FzdW1lIHRoYXQgY29uZGl0aW9uIGlzIG5vdCBtZXQKCiAgICAgIHZhciBoYXNEYXRhID0gdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAobGluZSkgewogICAgICAgIHJldHVybiBsaW5lLnZhbHVlcyA/IHRydWUgOiBmYWxzZTsKICAgICAgfSk7IC8vY2hlY2sgaWYgdmFsdWUgYXJyYXkgZXhpc3RzCgogICAgICBpZiAoaGFzRGF0YS5sZW5ndGggPiAwICYmIGhhc0RhdGEuZXZlcnkoZnVuY3Rpb24gKGJvb2wpIHsKICAgICAgICByZXR1cm4gYm9vbDsKICAgICAgfSkpIHN0YXRlID0gdHJ1ZTsgLy9jaGVjayBpZiBhbGwgbGluZXMgaGF2ZSBkYXRhIChhbmQgaWYgd2UgaGF2ZSBsaW5lcyBhdCBhbGwsIG90aGVyd2lzZSBjb25kaXRpb24gZm9yIGV2ZXJ5KCkgd291bGQgYmUgdHJ1ZSkKCiAgICAgIHJldHVybiBzdGF0ZTsKICAgIH0sCiAgICAvL2NvbXB1dGUgc2NhbGVzIGJhc2VkIG9uIHZhbHVlcyBvZiBhbGwgcGFzc2VkIGxpbmVzCiAgICBzY2FsZXM6IHsKICAgICAgY2FjaGU6IHRydWUsCiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgIHZhciBwYXJzZVRpbWUgPSBkMy50aW1lUGFyc2UodGhpcy4kc3RvcmUuc3RhdGUuZ3JhbnVsYXJpdHkpOwogICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7IC8vc2V0IHJhbmdlIHZvciBhbGwgc2NhbGVzIG9uIG1haW4gY2hhcnQKCiAgICAgICAgdmFyIHggPSBkMy5zY2FsZVRpbWUoKS5yYW5nZShbc3R5bGUubWFyZ2luLmxlZnQsIHN0eWxlLndpZHRoIC0gc3R5bGUubWFyZ2luLmxlZnQgLSBzdHlsZS5tYXJnaW4ucmlnaHRdKTsKICAgICAgICB2YXIgeSA9IGQzLnNjYWxlTGluZWFyKCkucmFuZ2UoW3N0eWxlLmhlaWdodCAtIHN0eWxlLm1hcmdpbi50b3AgLSBzdHlsZS5tYXJnaW4uYm90dG9tLCBzdHlsZS5tYXJnaW4uYm90dG9tXSk7CiAgICAgICAgdmFyIGNvbmZpZGVuY2UgPSBkMy5zY2FsZUxpbmVhcigpLnJhbmdlKHRoaXMubGluZVRoaWNrbmVzcyk7IC8vc2V0IHJhbmdlIHZvciBhbGwgc2NhbGVzIG9uIGJydXNoYWJsZSBtaWNybyBjaGFydAoKICAgICAgICB2YXIgbWljcm9YID0gZDMuc2NhbGVMaW5lYXIoKS5yYW5nZShbc3R5bGUubWFyZ2luLmxlZnQsIHN0eWxlLndpZHRoIC0gc3R5bGUubWFyZ2luLmxlZnQgLSBzdHlsZS5tYXJnaW4ucmlnaHRdKTsKICAgICAgICB2YXIgbWljcm9ZID0gZDMuc2NhbGVMaW5lYXIoKS5yYW5nZShbNDUsIDVdKTsgLy9iaW5kIHNjYWxlcyB0byBheGVzCgogICAgICAgIGQzLmF4aXNMZWZ0KCkuc2NhbGUoeCk7CiAgICAgICAgZDMuYXhpc0JvdHRvbSgpLnNjYWxlKHkpOyAvL2dldCBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlcyBmb3IgZWFjaCBsaW5lIChpIGtub3csIGl0J3Mgbm90IGVsZWdhbnQgOikKCiAgICAgICAgaWYgKHRoaXMuZGF0YVN0YXRlKSB7CiAgICAgICAgICB2YXIgYXJyID0gW107CiAgICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAobGluZSkgewogICAgICAgICAgICBsaW5lLnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkgewogICAgICAgICAgICAgIGFyci5wdXNoKHZhbHVlKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9KTsgLy9pZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lLCBnZXQgYSB0aGUgeERvbWFpbiBmcm9tIGRhdGEsIG90aGVyd2lzZSBpdCBoYXMgYmVlbiBzZXQgYnkgdGhlIGJydXNoCgogICAgICAgICAgdmFyIGRvbWFpbiA9IHRoaXMueERvbWFpbi5sZW5ndGggPiAwID8gdGhpcy54RG9tYWluIDogZDMuZXh0ZW50KGFyciwgZnVuY3Rpb24gKGQpIHsKICAgICAgICAgICAgcmV0dXJuIHBhcnNlVGltZShkLmQpOwogICAgICAgICAgfSk7IC8vc2V0IGRvbWFpbiBvZiBhbGwgc2NjYWxlcwoKICAgICAgICAgIHguZG9tYWluKGRvbWFpbik7CiAgICAgICAgICBtaWNyb1guZG9tYWluKGQzLmV4dGVudChhcnIsIGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICAgIHJldHVybiBwYXJzZVRpbWUoZC5kKTsKICAgICAgICAgIH0pKTsgLy9kZWZpbml0ZWx5IHNldCB0aGlzIHRvIHRoZSBtYXhpbXVtIGRhdGEgZG9tYWluIHNvIHdlIGNhbiBwdXNoIGl0IHRvIHRoZSBsaW1pdAoKICAgICAgICAgIHkuZG9tYWluKGQzLmV4dGVudChhcnIsIGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICAgIHJldHVybiArZC5yOwogICAgICAgICAgfSkpLm5pY2UoKTsKICAgICAgICAgIG1pY3JvWS5kb21haW4oZDMuZXh0ZW50KGFyciwgZnVuY3Rpb24gKGQpIHsKICAgICAgICAgICAgcmV0dXJuICtkLnI7CiAgICAgICAgICB9KSk7CiAgICAgICAgICBjb25maWRlbmNlLmRvbWFpbihkMy5leHRlbnQoYXJyLCBmdW5jdGlvbiAoZCkgewogICAgICAgICAgICByZXR1cm4gK2QuYzsKICAgICAgICAgIH0pKTsKICAgICAgICB9CgogICAgICAgIHJldHVybiB7CiAgICAgICAgICB4OiB4LAogICAgICAgICAgeTogeSwKICAgICAgICAgIG1pY3JvWDogbWljcm9YLAogICAgICAgICAgbWljcm9ZOiBtaWNyb1ksCiAgICAgICAgICBjb25maWRlbmNlOiBjb25maWRlbmNlCiAgICAgICAgfTsKICAgICAgfQogICAgfSwKICAgIC8vZm9yIGVhY2ggbGluZSwgY29tcHV0ZSB0aGUgYWN0dWFsIHBsb3QKICAgIGxpbmVzOiB7CiAgICAgIGNhY2hlOiBmYWxzZSwKICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7CgogICAgICAgIHZhciBwYXJzZVRpbWUgPSBkMy50aW1lUGFyc2UodGhpcy4kc3RvcmUuc3RhdGUuZ3JhbnVsYXJpdHkpOyAvL2dlbmVyYXRvciBmb3IgYXJlYSBmb3IgbWFpbiB2aXN1YWxpemF0aW9uCgogICAgICAgIHZhciBwYXRoID0gZDMuYXJlYSgpLmN1cnZlKGQzLmN1cnZlQmFzaXMpIC8vbWFrZSBjdXJ2ZSBzbW9vdGgKICAgICAgICAueChmdW5jdGlvbiAoZCkgewogICAgICAgICAgcmV0dXJuIF90aGlzMi5zY2FsZXMueChwYXJzZVRpbWUoZC5kKSk7CiAgICAgICAgfSkgLy9jb21wdXRlIHR3byB5LXZhbHVlcyBiYXNlZCBvbiBjb25maWRlbmNlKCkgLS0+IG51bWJlciBvZiByZXZpZXdzIHRoYXQgcHJvZHVjZSB0aGUgYXZlcmFnZSB2YWx1ZQogICAgICAgIC55MChmdW5jdGlvbiAoZCkgewogICAgICAgICAgcmV0dXJuIF90aGlzMi5zY2FsZXMueShkLnIpIC0gX3RoaXMyLnNjYWxlcy5jb25maWRlbmNlKGQuYyk7CiAgICAgICAgfSkueTEoZnVuY3Rpb24gKGQpIHsKICAgICAgICAgIHJldHVybiBfdGhpczIuc2NhbGVzLnkoZC5yKSArIF90aGlzMi5zY2FsZXMuY29uZmlkZW5jZShkLmMpOwogICAgICAgIH0pOyAvL2dlbmVyYXRvciBsaW5lIGZvciBicnVzaGFibGUgbWljcm8gdmlzdWFsemF0aW9uCgogICAgICAgIHZhciBtaWNybyA9IGQzLmxpbmUoKS5jdXJ2ZShkMy5jdXJ2ZUJhc2lzKS54KGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICByZXR1cm4gX3RoaXMyLnNjYWxlcy5taWNyb1gocGFyc2VUaW1lKGQuZCkpOwogICAgICAgIH0pLnkoZnVuY3Rpb24gKGQpIHsKICAgICAgICAgIHJldHVybiBfdGhpczIuc2NhbGVzLm1pY3JvWShkLnIpOwogICAgICAgIH0pOwogICAgICAgIHJldHVybiB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChsaW5lKSB7CiAgICAgICAgICBpZiAobGluZS52YWx1ZXMpIHsKICAgICAgICAgICAgLy9jb21wdXRlIHBhdGhzIGJhc2VkIG9uIGxpbmUgdmFsdWVzCiAgICAgICAgICAgIGxpbmUucGF0aCA9IHBhdGgobGluZS52YWx1ZXMpOwogICAgICAgICAgICBsaW5lLm1pY3JvID0gbWljcm8obGluZS52YWx1ZXMpOwogICAgICAgICAgfQoKICAgICAgICAgIHJldHVybiBsaW5lOwogICAgICAgIH0pOwogICAgICB9CiAgICB9CiAgfSwKICBkaXJlY3RpdmVzOiB7CiAgICBheGlzOiBmdW5jdGlvbiBheGlzKGVsLCBiaW5kaW5nKSB7CiAgICAgIC8vZHluYW1pY2FsbHkgY2FsbCBhbmQgdXBkYXRlIGF4aXMKICAgICAgdmFyIGF4aXMgPSBiaW5kaW5nLmFyZzsKICAgICAgdmFyIGF4aXNNZXRob2QgPSB7CiAgICAgICAgeDogImF4aXNCb3R0b20iLAogICAgICAgIHk6ICJheGlzTGVmdCIKICAgICAgfVtheGlzXTsKICAgICAgdmFyIG1ldGhvZEFyZyA9IGJpbmRpbmcudmFsdWVbYXhpc107CiAgICAgIGQzLnNlbGVjdChlbCkudHJhbnNpdGlvbigpLmNhbGwoZDNbYXhpc01ldGhvZF0obWV0aG9kQXJnKS50aWNrcyg1KSk7CiAgICB9CiAgfSwKICB3YXRjaDogewogICAgZGF0YVN0YXRlOiBmdW5jdGlvbiBkYXRhU3RhdGUobmV3U3RhdGUpIHsKICAgICAgLy9UT0RPOiBCcnVzaCBpcyBub3QgaW5pdGlhbGl6ZWQgd2hlbiB0aGUgc2l6ZSBpcyBpbml0aWFsbHkgbG9hZGVkLiBObyBpZGVhIHdoeS4KICAgICAgaWYgKG5ld1N0YXRlKSB0aGlzLmluaXRCcnVzaCgpOyAvL2luaXRpYWxpemUgYnJ1c2ggYXMgc29vbiBhcyB5b3UgaGF2ZSBkYXRhCiAgICB9LAogICAgc2NhbGVzOiBmdW5jdGlvbiBzY2FsZXMoKSB7CiAgICAgIHRoaXMuZGF0ZVBpY2tlciA9IHRoaXMuc2NhbGVzLnguZG9tYWluKCk7CiAgICB9CiAgfSwKICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkgewogICAgdGhpcy5nZXRXaWR0aCgpOwogICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkgewogICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5nZXRXaWR0aCk7CiAgICB9KTsKICB9LAogIG1ldGhvZHM6IHsKICAgIHBpY2tEYXRlOiBmdW5jdGlvbiBwaWNrRGF0ZShpKSB7CiAgICAgIHZhciBfdGhpczMgPSB0aGlzOwoKICAgICAgdmFyIHBhcnNlVGltZSA9IGQzLnRpbWVQYXJzZSgiJVktJW0tJWQiKTsKICAgICAgdGhpcy5kYXRlUGlja2VyW2ldID0gcGFyc2VUaW1lKHRoaXMuZGF0ZVBpY2tlcltpXSk7IC8vbWFrZSBzdXJlIGRhdGVzIGZyb20gdGhlIHBpY2tlciBhcmUgRGF0ZXMgYW5kIG5vdCBzdHJpbmdzICh3aHkgdGhlIGhlbGwgZG9lcyB0aGlzIGdpdmUgbWEgc3RyaW5ncyBhbnl3YXkpCgogICAgICB0aGlzLiRzZXQodGhpcy54RG9tYWluLCBpLCB0aGlzLmRhdGVQaWNrZXJbaV0pOyAvL3NldCB4IGF4aXMgZm9yIGJpZyB2aXMKCiAgICAgIGQzLnNlbGVjdCgiZy5icnVzaCIpLmNhbGwodGhpcy5icnVzaCkuY2FsbCh0aGlzLmJydXNoLm1vdmUsIHRoaXMuZGF0ZVBpY2tlci5tYXAoZnVuY3Rpb24gKGRhdGUpIHsKICAgICAgICByZXR1cm4gX3RoaXMzLnNjYWxlcy5taWNyb1goZGF0ZSk7CiAgICAgIH0pKTsKICAgIH0sCiAgICAvL2luaXRpYWxpemUgYnJ1c2ggKGRyYWdhYmxlIHNlbGVjdG9yIGZvciB4LWF4aXMpIGFuZCBhZGQgaXQgdG8gRE9NCiAgICBpbml0QnJ1c2g6IGZ1bmN0aW9uIGluaXRCcnVzaCgpIHsKICAgICAgdGhpcy5icnVzaCA9IGQzLmJydXNoWCgpLmV4dGVudCh0aGlzLnNjYWxlcy5taWNyb1gucmFuZ2UoKS5tYXAoZnVuY3Rpb24gKGUsIGkpIHsKICAgICAgICByZXR1cm4gW2UsIGkgKiA1MF07CiAgICAgIH0pKSAvL2JydXNoIHdpZHRoIGlzIHJhbmdlIG9mIHNjYWxlLCBoZWlnaHQgaXMgZml4ZWQgYXQgNTAKICAgICAgLm9uKCJlbmQiLCB0aGlzLnVwZGF0ZVgpOyAvLy5vbigiYnJ1c2ggZW5kIiwgdGhpcy51cGRhdGVYKSAvL3VwZGF0ZSBjb250aW5vdXNseSB3aGlsZSBtb3ZpbmcgKHRoaXMgbWF5IHJlc3VsdCBpbiBjcmFwIHBlcmZvcm1hbmNlKQoKICAgICAgZDMuc2VsZWN0KCJnLmJydXNoIikuY2FsbCh0aGlzLmJydXNoKS5jYWxsKHRoaXMuYnJ1c2gubW92ZSwgdGhpcy5zY2FsZXMueC5yYW5nZSgpKTsKICAgIH0sCiAgICAvL3NjYWxlIHgtYXhpcyBvZiB2aXN1YWxpemF0aW9uIHRvIGZpdCBib3VuZGFyaWVzIG9mIGJydXNoCiAgICB1cGRhdGVYOiBmdW5jdGlvbiB1cGRhdGVYKCkgewogICAgICB2YXIgX3RoaXM0ID0gdGhpczsKCiAgICAgIHZhciBkb21haW4gPSBkMy5ldmVudC5zZWxlY3Rpb24ubWFwKGZ1bmN0aW9uICh2YWx1ZSkgewogICAgICAgIHJldHVybiBfdGhpczQuc2NhbGVzLm1pY3JvWC5pbnZlcnQodmFsdWUpOwogICAgICB9KTsgLy9nZXQgbmV3IGRvbWFpbiBieSBnZXR0aW5nIGVkZ2VzIG9mIG92ZXJsYXkgYW5kIHRyYW5zbGF0ZSB0aGVtIHRvIGRhdGVzCgogICAgICBkb21haW4uZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGkpIHsKICAgICAgICBfdGhpczQuJHNldChfdGhpczQueERvbWFpbiwgaSwgdmFsdWUpOyAvL2l0ZXJhdGUgb3ZlciB0aGlzIGFycmF5IHRvIHRyaWdnZXIgcmVhY3Rpdml0eQoKICAgICAgfSk7CiAgICAgIGQzLnNlbGVjdCgiLnhBeGVzIikudHJhbnNpdGlvbigpLmNhbGwoZDMuYXhpc0JvdHRvbSh0aGlzLnNjYWxlcy54KSk7IC8vdXBkYXRlIEF4aXMKICAgIH0sCiAgICBnZXRXaWR0aDogZnVuY3Rpb24gZ2V0V2lkdGgoKSB7CiAgICAgIGlmICh0aGlzLiRyZWZzLnZpcykgewogICAgICAgIHRoaXMuc3R5bGUud2lkdGggPSB0aGlzLiRyZWZzLnZpcy5jbGllbnRXaWR0aDsKCiAgICAgICAgaWYgKHRoaXMuZGF0YVN0YXRlKSB7CiAgICAgICAgICB0aGlzLmluaXRCcnVzaCgpOwogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgIHNob3dUZXh0OiBmdW5jdGlvbiBzaG93VGV4dChhY3RpdmUsIGV2ZW50LCBpbmRleCkgewogICAgICB0aGlzLmN1cnJlbnRFdmVudCA9IGV2ZW50OwoKICAgICAgaWYgKGFjdGl2ZSkgewogICAgICAgIGQzLnNlbGVjdCgiLmV2ZW50LSIgKyBpbmRleCArICIgbGluZSIpLnRyYW5zaXRpb24oKS5hdHRyKCJzdHJva2Utd2lkdGgiLCA4KS5hdHRyKCJ4IiwgLTQpOwogICAgICB9IGVsc2UgewogICAgICAgIGQzLnNlbGVjdEFsbCgiLmV2ZW50cyBsaW5lIikudHJhbnNpdGlvbigpLmF0dHIoInN0cm9rZS13aWR0aCIsIDIpLmF0dHIoIngiLCAwKTsKICAgICAgfQogICAgfQogIH0KfTs="},{"version":3,"sources":["vis.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n  <div class=\"col-8\" ref=\"vis\">\n    <svg :width=\"style.width\" :height=\"style.height+style.margin.top + style.margin.bottom\" v-if=\"dataState\" class=\"lines\">\n\n      <!--SVG mask to hide overflow -->\n      <defs>\n        <clipPath id=\"mask\">\n          <rect :x=\"style.margin.left\" y=\"0\" :width=\"style.width\" :height=\"style.height-style.margin.top-style.margin.bottom\" />\n        </clipPath>\n      </defs>\n\n      <!-- axes -->\n      <g class=\"axes\" :transform=\"`translate(0,${style.margin.top})`\">\n        <text font-size=\"6pt\" y=\"-10\" :x=\"style.margin.left+10\" text-anchor=\"middle\">{{activeMetric.display}}</text>\n        <g v-axis:x=\"scales\" class=\"xAxes\" :transform=\"`translate(0,${style.height-style.margin.top-style.margin.bottom})`\"></g>\n        <g v-axis:y=\"scales\" class=\"yAxes\" :transform=\"`translate(${style.margin.left},0)`\"></g>\n      </g>\n\n      <!--event overlay -->\n      <g class=\"events\" v-if=\"showEvents\" clip-path=\"url(#mask)\" :transform=\"`translate(0,${style.margin.top})`\"  >\n        <g v-for=\"(event, index) in events\" :class=\"'event-'+index\" :key=\"`event-${index}`\" :transform=\"`translate(${event.x},0)`\">\n          <line x0=\"0\" :y0=\"style.margin.top\" x1=\"0\" :y1=\"style.height-style.margin.bottom-style.margin.top\" stroke=\"lightgrey\" stroke-width=\"2\" fill=\"lightgrey\" @mouseover=\"showText(true,event,index)\" @mouseout=\"showText(false,{date: '', text: ''},index)\" />\n        </g>\n      </g>\n\n      <!--lines -->\n      <g clip-path=\"url(#mask)\" :transform=\"`translate(0,${style.margin.top})`\">\n        <g class=\"lines\" v-for=\"line in lines\" v-bind:key=\"line.identifier\" >\n          <path v-if=\"line.path\" :d=\"line.path\" :fill=\"line.color\" stroke=\"none\"/>\n        </g>\n      </g>\n\n      <!-- legend in bottom right corner -->\n      <g class=\"legend\" :transform=\"`translate(${style.width-style.margin.right-50},${style.height-style.margin.bottom-50})`\">\n        <g>\n          <text text-anchor=\"end\">less confident</text>\n          <line x0=\"0\" x1=\"20\" y0=\"0\" y1=\"0\" transform=\"translate(2,-3)\" stroke=\"black\" stroke-width=\"2\"/>\n        </g>\n        <g transform=\"translate(0,10)\">\n          <text text-anchor=\"end\">more confident</text>\n          <line x0=\"0\" x1=\"20\" y0=\"0\" y1=\"0\" transform=\"translate(2,-3)\" stroke=\"black\" stroke-width=\"5\"/>\n        </g>\n      </g>\n    </svg>\n\n    <!--brush and datepickers for x-axis transformation -->\n    <div class=\"datePicker\">\n      <svg :width=\"style.width\" height=\"50\" style=\"background-color: lightgrey\">\n        <g v-if=\"dataState\">\n          <g class=\"lines\" v-for=\"line in lines\" v-bind:key=\"line.identifier\" >\n            <path v-if=\"line.micro\" :d=\"line.micro\" :stroke=\"line.color\" stroke-opacity=\"0.5\" fill=\"none\"/>\n          </g>\n        </g>\n        <g class=\"brush\" />\n      </svg>\n\n      <div class=\"row\">\n        <VueDatePicker  v-for=\"(date,i) in datePicker\" :key=\"i\" class=\"col\" @onChange=\"pickDate(i)\" v-model=\"datePicker[i]\" />\n      </div>\n    </div>\n\n    <div class=\"events\">\n      <form>\n        <div class=\"form-check\">\n          <input type=\"checkbox\" class=\"form-check-input\" id=\"exampleCheck1\" v-model=\"showEvents\" @click=\"showEvents = !showEvents\">\n          <label class=\"form-check-label\" for=\"exampleCheck1\">Events:</label>\n        </div>\n      </form>\n      <div class=\"currentEvent\">\n        <span>{{currentEvent.date}}</span>\n        <p>{{currentEvent.text}}</p>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport * as d3 from 'd3'\nimport { VueDatePicker } from '@mathieustan/vue-datepicker';\nimport '@mathieustan/vue-datepicker/dist/vue-datepicker.min.css';\n\nexport default {\n  components : {\n    VueDatePicker,\n  },\n  data() {\n    return {\n      showEvents: true,\n      currentEvent: {},\n      xDomain: [],\n      datePicker: [], //empty array to pass dates between datepicker and scales\n      brush: null,\n      lineThickness: [3,7],\n      style: {\n        width: 1000, //TODO: set to window width\n        height: 300,\n        margin: {\n          top: 30,\n          right: 25,\n          bottom: 0 ,\n          left: 40\n        }\n      },\n    }\n  },\n\n  computed: {\n    events: { //get additional information from store\n      cache: true,\n      get: function() {\n        let parseTime = d3.timeParse(\"%d-%m-%Y\");\n        let events = this.$store.state.events.map(event => {\n          event.x = this.scales.x(parseTime(event.date)) //translate date to position\n          return event\n        })\n        return events\n      }\n    },\n\n\n    activeMetric: function() {return this.$store.getters.getActiveMetric},\n\n    //get data from store (this is the computed property \"data\", not vue's data property)\n    data: {\n      cache: false,\n      get: function() {\n        return this.$store.getters.getLines.map(line => {\n          line.touched = 0 //add counter for reactivity when using brush function\n          return line\n        })\n      }\n    },\n\n    //check if every line we received also has data values before we render\n    dataState: function() {\n      let state = false //asume that condition is not met\n      let hasData = this.data.map(line => (line.values) ? true : false) //check if value array exists\n      if(hasData.length > 0 && hasData.every(bool => bool)) state = true //check if all lines have data (and if we have lines at all, otherwise condition for every() would be true)\n      return state\n    },\n\n    //compute scales based on values of all passed lines\n    scales: {\n      cache: true,\n      get() {\n        let parseTime = d3.timeParse(this.$store.state.granularity);\n        let style = this.style\n\n        //set range vor all scales on main chart\n        const x = d3.scaleTime().range([style.margin.left,style.width - style.margin.left - style.margin.right]);\n        const y = d3.scaleLinear().range([\n          style.height - style.margin.top - style.margin.bottom,\n          style.margin.bottom\n        ]);\n        const confidence = d3.scaleLinear().range(this.lineThickness)\n\n        //set range vor all scales on brushable micro chart\n        const microX = d3.scaleLinear().range([style.margin.left,style.width - style.margin.left - style.margin.right]);\n        const microY = d3.scaleLinear().range([45,5]);\n\n        //bind scales to axes\n        d3.axisLeft().scale(x);\n        d3.axisBottom().scale(y);\n\n        //get minimum and maximum values for each line (i know, it's not elegant :)\n        if(this.dataState) {\n          let arr = []\n          this.data.forEach(line => {\n            line.values.forEach(value => {\n              arr.push(value)\n            })\n          })\n\n          //if this is the first time, get a the xDomain from data, otherwise it has been set by the brush\n          let domain = (this.xDomain.length > 0) ? this.xDomain : d3.extent(arr, d => parseTime(d.d))\n\n          //set domain of all sccales\n          x.domain(domain);\n          microX.domain(d3.extent(arr, d => parseTime(d.d))); //definitely set this to the maximum data domain so we can push it to the limit\n          y.domain(d3.extent(arr, d => +d.r)).nice();\n          microY.domain(d3.extent(arr, d => +d.r));\n          confidence.domain(d3.extent(arr, d => +d.c))\n        }\n\n        return { x, y, microX, microY, confidence };\n      }\n    },\n\n    //for each line, compute the actual plot\n    lines: {\n      cache: false,\n      get: function() {\n        let parseTime = d3.timeParse(this.$store.state.granularity);\n\n        //generator for area for main visualization\n         const path = d3.area()\n         .curve(d3.curveBasis) //make curve smooth\n         .x(d => this.scales.x(parseTime(d.d)))\n         //compute two y-values based on confidence() --> number of reviews that produce the average value\n         .y0(d => this.scales.y(d.r)-this.scales.confidence(d.c))\n         .y1(d => this.scales.y(d.r)+this.scales.confidence(d.c));\n\n         //generator line for brushable micro visualzation\n         const micro = d3.line()\n         .curve(d3.curveBasis)\n         .x(d => this.scales.microX(parseTime(d.d)))\n         .y(d => this.scales.microY(d.r));\n\n         return this.data.map(line => {\n           if(line.values) {\n             //compute paths based on line values\n             line.path = path(line.values)\n             line.micro = micro(line.values)\n           }\n           return line\n         })\n      }\n    },\n  },\n\n\n\n  directives: {\n    axis(el, binding) {//dynamically call and update axis\n      const axis = binding.arg;\n      const axisMethod = { x: \"axisBottom\", y: \"axisLeft\" }[axis];\n      const methodArg = binding.value[axis];\n      d3.select(el).transition().call(d3[axisMethod](methodArg).ticks(5));\n    },\n  },\n\n  watch: {\n    dataState: function(newState) {\n      //TODO: Brush is not initialized when the size is initially loaded. No idea why.\n      if(newState) this.initBrush() //initialize brush as soon as you have data\n    },\n\n    scales: function() {\n      this.datePicker = this.scales.x.domain()\n    }\n  },\n\n\n\n  mounted () {\n    this.getWidth()\n    this.$nextTick(function() {\n      window.addEventListener('resize', this.getWidth);\n    })\n  },\n\n  methods: {\n    pickDate: function(i) {\n      let parseTime = d3.timeParse(\"%Y-%m-%d\");\n      this.datePicker[i] = parseTime(this.datePicker[i]) //make sure dates from the picker are Dates and not strings (why the hell does this give ma strings anyway)\n\n      this.$set(this.xDomain,i,this.datePicker[i]) //set x axis for big vis\n\n      d3.select(\"g.brush\")\n        .call(this.brush)\n        .call(this.brush.move, this.datePicker.map(date => this.scales.microX(date)))\n    },\n\n\n    //initialize brush (dragable selector for x-axis) and add it to DOM\n    initBrush: function() {\n      this.brush = d3.brushX()\n        .extent(this.scales.microX.range().map((e,i) => [e,i*50])) //brush width is range of scale, height is fixed at 50\n        .on(\"end\", this.updateX)\n        //.on(\"brush end\", this.updateX) //update continously while moving (this may result in crap performance)\n\n      d3.select(\"g.brush\")\n        .call(this.brush)\n        .call(this.brush.move, this.scales.x.range())\n    },\n    //scale x-axis of visualization to fit boundaries of brush\n    updateX: function() {\n      let domain = d3.event.selection.map(value => this.scales.microX.invert(value)) //get new domain by getting edges of overlay and translate them to dates\n      domain.forEach((value,i) => {\n        this.$set(this.xDomain,i,value) //iterate over this array to trigger reactivity\n      })\n\n      d3.select(\".xAxes\").transition().call(d3.axisBottom(this.scales.x)) //update Axis\n    },\n\n    getWidth: function() {\n      if(this.$refs.vis) {\n        this.style.width = this.$refs.vis.clientWidth\n        if(this.dataState) {\n          this.initBrush()\n        }\n      }\n    },\n    showText: function(active,event,index) {\n      this.currentEvent = event\n      if(active) {\n        d3.select(\".event-\"+index+\" line\").transition().attr(\"stroke-width\",8).attr(\"x\",-4)\n      } else {\n        d3.selectAll(\".events line\").transition().attr(\"stroke-width\",2).attr(\"x\",0)\n      }\n\n    }\n  }\n}\n</script>\n\n<style scoped>\ndiv {\n  background-color: #F7F7F7;\n}\nsvg.lines {\n  margin-top: 50px;\n  background-color: white;\n}\npath {\n  transition: d .3s\n}\n\n.legend {\n  font-size: 6pt;\n}\n\n.events {\n  margin-top: 50px;\n}\n\n.currentEvent span {\n  font-size: .8em;\n  font-weight: bold;\n}\n\n.vd-wrapper.picker-1 {\nfloat: right;\n}\n\n.currentEvent text {\n  font-size: 10px;\n}\n</style>\n"],"sourceRoot":"src/components"}]}