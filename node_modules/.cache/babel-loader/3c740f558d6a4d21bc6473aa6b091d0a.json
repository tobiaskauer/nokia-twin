{"remainingRequest":"/Users/tk/GitHub/nokiatwin/node_modules/babel-loader/lib/index.js!/Users/tk/GitHub/nokiatwin/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/tk/GitHub/nokiatwin/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/tk/GitHub/nokiatwin/src/components/vis.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/tk/GitHub/nokiatwin/src/components/vis.vue","mtime":1596709286938},{"path":"/Users/tk/GitHub/nokiatwin/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/tk/GitHub/nokiatwin/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/tk/GitHub/nokiatwin/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/tk/GitHub/nokiatwin/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZXZlcnkiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXIiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2giOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yIjsKLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnOyAvL2ltcG9ydCB7IHJlZ3Jlc3Npb25MaW5lYXIgfSBmcm9tICdkMy1yZWdyZXNzaW9uJzsKCmV4cG9ydCBkZWZhdWx0IHsKICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkgewogICAgcmV0dXJuIHsKICAgICAgc2hvd0NvbnRleHQ6IHRydWUsCiAgICAgIHhEb21haW46IFtdLAogICAgICBzdHlsZTogewogICAgICAgIHdpZHRoOiAxMDAwLAogICAgICAgIC8vVE9ETzogc2V0IHRvIHdpbmRvdyB3aWR0aAogICAgICAgIGhlaWdodDogMzAwLAogICAgICAgIG1hcmdpbjogewogICAgICAgICAgdG9wOiAyNSwKICAgICAgICAgIHJpZ2h0OiAyNSwKICAgICAgICAgIGJvdHRvbTogMCwKICAgICAgICAgIGxlZnQ6IDQwCiAgICAgICAgfQogICAgICB9CiAgICB9OwogIH0sCiAgY29tcHV0ZWQ6IHsKICAgIGNvbnRleHQ6IHsKICAgICAgLy9nZXQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBmcm9tIHN0b3JlCiAgICAgIGNhY2hlOiBmYWxzZSwKICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgdmFyIF90aGlzID0gdGhpczsKCiAgICAgICAgdmFyIHBhcnNlVGltZSA9IGQzLnRpbWVQYXJzZSgiJVktJW0iKTsKICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldENvbnRleHQubWFwKGZ1bmN0aW9uIChpdGVtKSB7CiAgICAgICAgICBpdGVtLnggPSBfdGhpcy5zY2FsZXMueChwYXJzZVRpbWUoaXRlbS5kYXRlKSk7IC8vdHJhbnNsYXRlIGRhdGUgdG8gcG9zaXRpb24KCiAgICAgICAgICByZXR1cm4gaXRlbTsKICAgICAgICB9KTsKICAgICAgICByZXR1cm4gaXRlbXM7CiAgICAgIH0KICAgIH0sCiAgICAvL2dldCBkYXRhIGZyb20gc3RvcmUgKHRoaXMgaXMgdGhlIGNvbXB1dGVkIHByb3BlcnR5ICJkYXRhIiwgbm90IHZ1ZSdzIGRhdGEgcHJvcGVydHkpCiAgICBkYXRhOiB7CiAgICAgIGNhY2hlOiBmYWxzZSwKICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZ2V0TGluZXMubWFwKGZ1bmN0aW9uIChsaW5lKSB7CiAgICAgICAgICBsaW5lLnRvdWNoZWQgPSAwOyAvL2FkZCBjb3VudGVyIGZvciByZWFjdGl2aXR5IHdoZW4gdXNpbmcgYnJ1c2ggZnVuY3Rpb24KCiAgICAgICAgICByZXR1cm4gbGluZTsKICAgICAgICB9KTsKICAgICAgfQogICAgfSwKICAgIC8vY2hlY2sgaWYgZXZlcnkgbGluZSB3ZSByZWNlaXZlZCBhbHNvIGhhcyBkYXRhIHZhbHVlcyBiZWZvcmUgd2UgcmVuZGVyCiAgICBkYXRhU3RhdGU6IGZ1bmN0aW9uIGRhdGFTdGF0ZSgpIHsKICAgICAgdmFyIHN0YXRlID0gZmFsc2U7IC8vYXN1bWUgdGhhdCBjb25kaXRpb24gaXMgbm90IG1ldAoKICAgICAgdmFyIGhhc0RhdGEgPSB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChsaW5lKSB7CiAgICAgICAgcmV0dXJuIGxpbmUudmFsdWVzID8gdHJ1ZSA6IGZhbHNlOwogICAgICB9KTsgLy9jaGVjayBpZiB2YWx1ZSBhcnJheSBleGlzdHMKCiAgICAgIGlmIChoYXNEYXRhLmxlbmd0aCA+IDAgJiYgaGFzRGF0YS5ldmVyeShmdW5jdGlvbiAoYm9vbCkgewogICAgICAgIHJldHVybiBib29sOwogICAgICB9KSkgc3RhdGUgPSB0cnVlOyAvL2NoZWNrIGlmIGFsbCBsaW5lcyBoYXZlIGRhdGEgKGFuZCBpZiB3ZSBoYXZlIGxpbmVzIGF0IGFsbCwgb3RoZXJ3aXNlIGNvbmRpdGlvbiBmb3IgZXZlcnkoKSB3b3VsZCBiZSB0cnVlKQoKICAgICAgcmV0dXJuIHN0YXRlOwogICAgfSwKICAgIC8vY29tcHV0ZSBzY2FsZXMgYmFzZWQgb24gdmFsdWVzIG9mIGFsbCBwYXNzZWQgbGluZXMKICAgIHNjYWxlczogewogICAgICBjYWNoZTogdHJ1ZSwKICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgdmFyIHBhcnNlVGltZSA9IGQzLnRpbWVQYXJzZSgiJVktJW0iKTsKICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlOyAvL3NldCByYW5nZSB2b3IgYWxsIHNjYWxlcyBvbiBtYWluIGNoYXJ0CgogICAgICAgIHZhciB4ID0gZDMuc2NhbGVUaW1lKCkucmFuZ2UoW3N0eWxlLm1hcmdpbi5sZWZ0LCBzdHlsZS53aWR0aCAtIHN0eWxlLm1hcmdpbi5sZWZ0IC0gc3R5bGUubWFyZ2luLnJpZ2h0XSk7CiAgICAgICAgdmFyIHkgPSBkMy5zY2FsZUxpbmVhcigpLnJhbmdlKFtzdHlsZS5oZWlnaHQgLSBzdHlsZS5tYXJnaW4udG9wIC0gc3R5bGUubWFyZ2luLmJvdHRvbSwgc3R5bGUubWFyZ2luLmJvdHRvbV0pOwogICAgICAgIHZhciBjb25maWRlbmNlID0gZDMuc2NhbGVMaW5lYXIoKS5yYW5nZShbMywgNl0pOyAvL3NldCByYW5nZSB2b3IgYWxsIHNjYWxlcyBvbiBicnVzaGFibGUgbWljcm8gY2hhcnQKCiAgICAgICAgdmFyIG1pY3JvWCA9IGQzLnNjYWxlTGluZWFyKCkucmFuZ2UoW3N0eWxlLm1hcmdpbi5sZWZ0LCBzdHlsZS53aWR0aCAtIHN0eWxlLm1hcmdpbi5sZWZ0IC0gc3R5bGUubWFyZ2luLnJpZ2h0XSk7CiAgICAgICAgdmFyIG1pY3JvWSA9IGQzLnNjYWxlTGluZWFyKCkucmFuZ2UoWzQ1LCA1XSk7IC8vYmluZCBzY2FsZXMgdG8gYXhlcwoKICAgICAgICBkMy5heGlzTGVmdCgpLnNjYWxlKHgpOwogICAgICAgIGQzLmF4aXNCb3R0b20oKS5zY2FsZSh5KTsgLy9nZXQgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXMgZm9yIGVhY2ggbGluZSAoaSBrbm93LCBpdCdzIG5vdCBlbGVnYW50IDopCgogICAgICAgIGlmICh0aGlzLmRhdGFTdGF0ZSkgewogICAgICAgICAgdmFyIGFyciA9IFtdOwogICAgICAgICAgdGhpcy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHsKICAgICAgICAgICAgbGluZS52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHsKICAgICAgICAgICAgICBhcnIucHVzaCh2YWx1ZSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSk7IC8vaWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSwgZ2V0IGEgdGhlIHhEb21haW4gZnJvbSBkYXRhLCBvdGhlcndpc2UgaXQgaGFzIGJlZW4gc2V0IGJ5IHRoZSBicnVzaAoKICAgICAgICAgIHZhciBkb21haW4gPSB0aGlzLnhEb21haW4ubGVuZ3RoID4gMCA/IHRoaXMueERvbWFpbiA6IGQzLmV4dGVudChhcnIsIGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICAgIHJldHVybiBwYXJzZVRpbWUoZC5kKTsKICAgICAgICAgIH0pOyAvL3NldCBkb21haW4gb2YgYWxsIHNjY2FsZXMKCiAgICAgICAgICB4LmRvbWFpbihkb21haW4pOwogICAgICAgICAgbWljcm9YLmRvbWFpbihkMy5leHRlbnQoYXJyLCBmdW5jdGlvbiAoZCkgewogICAgICAgICAgICByZXR1cm4gcGFyc2VUaW1lKGQuZCk7CiAgICAgICAgICB9KSk7IC8vZGVmaW5pdGVseSBzZXQgdGhpcyB0byB0aGUgbWF4aW11bSBkYXRhIGRvbWFpbiBzbyB3ZSBjYW4gcHVzaCBpdCB0byB0aGUgbGltaXQKCiAgICAgICAgICB5LmRvbWFpbihkMy5leHRlbnQoYXJyLCBmdW5jdGlvbiAoZCkgewogICAgICAgICAgICByZXR1cm4gK2QucjsKICAgICAgICAgIH0pKS5uaWNlKCk7CiAgICAgICAgICBtaWNyb1kuZG9tYWluKGQzLmV4dGVudChhcnIsIGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICAgIHJldHVybiArZC5yOwogICAgICAgICAgfSkpOwogICAgICAgICAgY29uZmlkZW5jZS5kb21haW4oZDMuZXh0ZW50KGFyciwgZnVuY3Rpb24gKGQpIHsKICAgICAgICAgICAgcmV0dXJuICtkLmM7CiAgICAgICAgICB9KSk7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gewogICAgICAgICAgeDogeCwKICAgICAgICAgIHk6IHksCiAgICAgICAgICBtaWNyb1g6IG1pY3JvWCwKICAgICAgICAgIG1pY3JvWTogbWljcm9ZLAogICAgICAgICAgY29uZmlkZW5jZTogY29uZmlkZW5jZQogICAgICAgIH07CiAgICAgIH0KICAgIH0sCiAgICBleHRyZW1lVmFsdWVzOiBmdW5jdGlvbiBleHRyZW1lVmFsdWVzKCkgewogICAgICB2YXIgX3RoaXMyID0gdGhpczsKCiAgICAgIHZhciBwYXJzZVRpbWUgPSBkMy50aW1lUGFyc2UoIiVZLSVtIik7CiAgICAgIHZhciBkb21haW4gPSB0aGlzLnNjYWxlcy54LmRvbWFpbigpOwogICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAobGluZSkgewogICAgICAgIC8vY3JlYXRlIGFycmF5IGZvciBhbGwgbGluZXMuIGxvb2sgaW4gYWxsIGxpbmVzLi4uCiAgICAgICAgLy9sb29rIGZvciB2YWx1ZXMgdGhhdCBhcmUgd2l0aGluIHRoZSB2aXNpYmxlIGJvdW5kYXJpZXMgb2YgdGhlIHgtYXhpcwogICAgICAgIHZhciB2aXNpYmxlID0gbGluZS52YWx1ZXMuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkgewogICAgICAgICAgdmFyIGRhdGUgPSBwYXJzZVRpbWUodmFsdWUuZCk7CiAgICAgICAgICByZXR1cm4gZGF0ZSA+IGRvbWFpblswXSAmJiBkYXRlIDwgZG9tYWluWzFdID8gdHJ1ZSA6IGZhbHNlOwogICAgICAgIH0pOyAvL2Zvcm0gdGhvc2UsIGdldCB0d28gcGVha3MgYW5kIHR3byB2YWxsZXkgdmFsdWVzCgogICAgICAgIHZhciBzb3J0ZWQgPSB2aXNpYmxlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsKICAgICAgICAgIHJldHVybiBhLnIgLSBiLnI7CiAgICAgICAgfSk7CiAgICAgICAgdmFyIGV4dHJlbWUgPSBzb3J0ZWQuc2xpY2UoMCwgMikuY29uY2F0KHNvcnRlZC5zbGljZShzb3J0ZWQubGVuZ3RoIC0gMiwgc29ydGVkLmxlbmd0aCkpOwogICAgICAgIHZhciBjaXJjbGVzID0gZXh0cmVtZS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICB4OiBfdGhpczIuc2NhbGVzLngocGFyc2VUaW1lKHZhbHVlLmQpKSwKICAgICAgICAgICAgeTogX3RoaXMyLnNjYWxlcy55KHZhbHVlLnIpCiAgICAgICAgICB9OwogICAgICAgIH0pOwogICAgICAgIHZhciBvYmogPSB7CiAgICAgICAgICBjb2xvcjogbGluZS5jb2xvciwKICAgICAgICAgIGNpcmNsZXM6IGNpcmNsZXMKICAgICAgICB9OwogICAgICAgIHJldHVybiBvYmo7CiAgICAgIH0pOwogICAgfSwKICAgIC8vZm9yIGVhY2ggbGluZSwgY29tcHV0ZQogICAgbGluZXM6IHsKICAgICAgY2FjaGU6IGZhbHNlLAogICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICB2YXIgX3RoaXMzID0gdGhpczsKCiAgICAgICAgdmFyIHBhcnNlVGltZSA9IGQzLnRpbWVQYXJzZSgiJVktJW0iKTsgLy9nZW5lcmF0b3IgZm9yIGFyZWEgZm9yIG1haW4gdmlzdWFsaXphdGlvbgoKICAgICAgICB2YXIgcGF0aCA9IGQzLmFyZWEoKS5jdXJ2ZShkMy5jdXJ2ZUJhc2lzKSAvL21ha2UgY3VydmUgc21vb3RoCiAgICAgICAgLngoZnVuY3Rpb24gKGQpIHsKICAgICAgICAgIHJldHVybiBfdGhpczMuc2NhbGVzLngocGFyc2VUaW1lKGQuZCkpOwogICAgICAgIH0pIC8vY29tcHV0ZSB0d28geS12YWx1ZXMgYmFzZWQgb24gY29uZmlkZW5jZSgpIC0tPiBudW1iZXIgb2YgcmV2aWV3cyB0aGF0IHByb2R1Y2UgdGhlIGF2ZXJhZ2UgdmFsdWUKICAgICAgICAueTAoZnVuY3Rpb24gKGQpIHsKICAgICAgICAgIHJldHVybiBfdGhpczMuc2NhbGVzLnkoZC5yKSAtIF90aGlzMy5zY2FsZXMuY29uZmlkZW5jZShkLmMpOwogICAgICAgIH0pLnkxKGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICByZXR1cm4gX3RoaXMzLnNjYWxlcy55KGQucikgKyBfdGhpczMuc2NhbGVzLmNvbmZpZGVuY2UoZC5jKTsKICAgICAgICB9KTsKICAgICAgICAvKmNvbnN0IHBhdGggPSBkMy5saW5lKCkKICAgICAgICAueChkID0+IHRoaXMuc2NhbGVzLngocGFyc2VUaW1lKGQuZCkpKQogICAgICAgIC55KGQgPT4gdGhpcy5zY2FsZXMueShkLnIpKTsqLwogICAgICAgIC8vZ2VuZXJhdG9yIGxpbmUgZm9yIGJydXNoYWJsZSBtaWNybyB2aXN1YWx6YXRpb24KCiAgICAgICAgdmFyIG1pY3JvID0gZDMubGluZSgpLmN1cnZlKGQzLmN1cnZlQmFzaXMpLngoZnVuY3Rpb24gKGQpIHsKICAgICAgICAgIHJldHVybiBfdGhpczMuc2NhbGVzLm1pY3JvWChwYXJzZVRpbWUoZC5kKSk7CiAgICAgICAgfSkueShmdW5jdGlvbiAoZCkgewogICAgICAgICAgcmV0dXJuIF90aGlzMy5zY2FsZXMubWljcm9ZKGQucik7CiAgICAgICAgfSk7CiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5tYXAoZnVuY3Rpb24gKGxpbmUpIHsKICAgICAgICAgIGlmIChsaW5lLnZhbHVlcykgewogICAgICAgICAgICAvL2NvbXB1dGUgcGF0aHMgYmFzZWQgb24gbGluZSB2YWx1ZXMKICAgICAgICAgICAgbGluZS5wYXRoID0gcGF0aChsaW5lLnZhbHVlcyk7CiAgICAgICAgICAgIGxpbmUubWljcm8gPSBtaWNybyhsaW5lLnZhbHVlcyk7CiAgICAgICAgICB9CgogICAgICAgICAgcmV0dXJuIGxpbmU7CiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0KICB9LAogIGRpcmVjdGl2ZXM6IHsKICAgIGF4aXM6IGZ1bmN0aW9uIGF4aXMoZWwsIGJpbmRpbmcpIHsKICAgICAgLy9keW5hbWljYWxseSBjYWxsIGFuZCB1cGRhdGUgYXhpcwogICAgICB2YXIgYXhpcyA9IGJpbmRpbmcuYXJnOwogICAgICB2YXIgYXhpc01ldGhvZCA9IHsKICAgICAgICB4OiAiYXhpc0JvdHRvbSIsCiAgICAgICAgeTogImF4aXNMZWZ0IgogICAgICB9W2F4aXNdOwogICAgICB2YXIgbWV0aG9kQXJnID0gYmluZGluZy52YWx1ZVtheGlzXTsKICAgICAgZDMuc2VsZWN0KGVsKS50cmFuc2l0aW9uKCkuY2FsbChkM1theGlzTWV0aG9kXShtZXRob2RBcmcpLnRpY2tzKDUpKTsKICAgIH0KICB9LAogIHdhdGNoOiB7CiAgICBkYXRhU3RhdGU6IGZ1bmN0aW9uIGRhdGFTdGF0ZShuZXdTdGF0ZSkgewogICAgICAvL1RPRE86IEJydXNoIGlzIG5vdCBpbml0aWFsaXplZCB3aGVuIHRoZSBzaXplIGlzIGluaXRpYWxseSBsb2FkZWQuIE5vIGlkZWEgd2h5LgogICAgICBpZiAobmV3U3RhdGUpIHRoaXMuYnJ1c2goKTsgLy9pbml0aWFsaXplIGJydXNoIGFzIHNvb24gYXMgeW91IGhhdmUgZGF0YQogICAgfQogIH0sCiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHsKICAgIHRoaXMuZ2V0V2lkdGgoKTsKICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHsKICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuZ2V0V2lkdGgpOwogICAgfSk7CiAgfSwKICBtZXRob2RzOiB7CiAgICAvL2luaXRpYWxpemUgYnJ1c2ggKGRyYWdhYmxlIHNlbGVjdG9yIGZvciB4LWF4aXMpIGFuZCBhZGQgaXQgdG8gRE9NCiAgICBicnVzaDogZnVuY3Rpb24gYnJ1c2goKSB7CiAgICAgIHZhciBicnVzaCA9IGQzLmJydXNoWCgpLmV4dGVudCh0aGlzLnNjYWxlcy5taWNyb1gucmFuZ2UoKS5tYXAoZnVuY3Rpb24gKGUsIGkpIHsKICAgICAgICByZXR1cm4gW2UsIGkgKiA1MF07CiAgICAgIH0pKS5vbigiZW5kIiwgdGhpcy51cGRhdGVYKTsgLy8ub24oImJydXNoIGVuZCIsIHRoaXMudXBkYXRlWCkgLy91cGRhdGUgY29udGlub3VzbHkgd2hpbGUgbW92aW5nICh0aGlzIG1heSByZXN1bHQgaW4gY3JhcCBwZXJmb3JtYW5jZSkKCiAgICAgIGQzLnNlbGVjdCgiZy5icnVzaCIpLmNhbGwoYnJ1c2gpLmNhbGwoYnJ1c2gubW92ZSwgdGhpcy5zY2FsZXMueC5yYW5nZSgpKTsKICAgIH0sCiAgICAvL3NjYWxlIHgtYXhpcyBvZiB2aXN1YWxpemF0aW9uIHRvIGZpdCBib3VuZGFyaWVzIG9mIGJydXNoCiAgICB1cGRhdGVYOiBmdW5jdGlvbiB1cGRhdGVYKCkgewogICAgICB2YXIgX3RoaXM0ID0gdGhpczsKCiAgICAgIHZhciBkb21haW4gPSBkMy5ldmVudC5zZWxlY3Rpb24ubWFwKGZ1bmN0aW9uICh2YWx1ZSkgewogICAgICAgIHJldHVybiBfdGhpczQuc2NhbGVzLm1pY3JvWC5pbnZlcnQodmFsdWUpOwogICAgICB9KTsgLy9nZXQgbmV3IGRvbWFpbiBieSBnZXR0aW5nIGVkZ2VzIG9mIG92ZXJsYXkgYW5kIHRyYW5zbGF0ZSB0aGVtIHRvIGRhdGVzCgogICAgICBkb21haW4uZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGkpIHsKICAgICAgICBfdGhpczQuJHNldChfdGhpczQueERvbWFpbiwgaSwgdmFsdWUpOyAvL2l0ZXJhdGUgb3ZlciB0aGlzIGFycmF5IHRvIHRyaWdnZXIgcmVhY3Rpdml0eQoKICAgICAgfSk7CiAgICAgIGQzLnNlbGVjdCgiLnhBeGVzIikudHJhbnNpdGlvbigpLmNhbGwoZDMuYXhpc0JvdHRvbSh0aGlzLnNjYWxlcy54KSk7IC8vdXBkYXRlIEF4aXMKICAgIH0sCiAgICBnZXRXaWR0aDogZnVuY3Rpb24gZ2V0V2lkdGgoKSB7CiAgICAgIGNvbnNvbGUubG9nKCJvdXRlciIpOwoKICAgICAgaWYgKHRoaXMuZGF0YVN0YXRlKSB7CiAgICAgICAgY29uc29sZS5sb2coImRhdGFTdGF0ZSIpOwogICAgICAgIHRoaXMuc3R5bGUud2lkdGggPSB0aGlzLiRyZWZzLnZpcy5jbGllbnRXaWR0aDsKICAgICAgfQoKICAgICAgaWYgKHRoaXMuJHJlZnMudmlzKSBjb25zb2xlLmxvZygicmVmcyB2aXMiKTsKICAgIH0KICB9CiAgLypwcm9wczogewogIH0sCiAgCiAgY3JlYXRlZCAoKSB7CiAgfSwKICAgbWV0aG9kczogewogIH0sKi8KCn07"},{"version":3,"sources":["vis.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n  <div class=\"col-8\" ref=\"vis\">\n    <!--<div v-if=\"dataState\">\n      <div v-for=\"(line,index) in lines\" v-bind:key=\"index\">{{line.query}}</div>\n    </div>-->\n    <svg :width=\"style.width\" :height=\"style.height\" v-if=\"dataState\" class=\"lines\">\n      <g class=\"axes\">\n        <g v-axis:x=\"scales\" class=\"xAxes\" :transform=\"`translate(0,${style.height-style.margin.top-style.margin.bottom})`\"></g>\n        <g v-axis:y=\"scales\" class=\"yAxes\" :transform=\"`translate(${style.margin.left},0)`\"></g>\n      </g>\n      <g class=\"context\" v-if=\"showContext\">\n        <g v-for=\"(item, index) in context\" :key=\"`context-${index}`\" :transform=\"`translate(${item.x},0)`\">\n          <line x1=\"0\" x2=\"0\" :y1=\"style.margin.top\" :y2=\"style.height-style.margin.bottom-style.margin.top\" stroke=\"black\" stroke-dasharray=\"4\" />\n          <text x=\"10\" :y=\"style.margin.top+20\">{{item.text}}</text>\n        </g>\n      </g>\n      <g class=\"extremeValues\" v-if=\"dataState\">\n        <g v-for=\"(extremeLine, index) in extremeValues\" v-bind:key=\"'extreme-'+index\">\n          <circle v-for=\"(circle, index) in extremeLine.circles\" :key=\"'circle-'+index\" :cx=\"circle.x\" :cy=\"circle.y\" r=\"10\" fill=\"none\" :stroke=\"extremeLine.color\" stroke-width=\"1\" stroke-dasharray=\"4 1\"/>\n        </g>\n      </g>\n      <g class=\"legend\" :transform=\"`translate(${style.width-style.margin.right-50},${style.height-style.margin.bottom-50})`\">\n        <g>\n          <text text-anchor=\"end\">less confident</text>\n          <line x0=\"0\" x1=\"20\" y0=\"0\" y1=\"0\" transform=\"translate(2,-3)\" stroke=\"black\" stroke-width=\"2\"/>\n        </g>\n        <g transform=\"translate(0,10)\">\n          <text text-anchor=\"end\">more confident</text>\n          <line x0=\"0\" x1=\"20\" y0=\"0\" y1=\"0\" transform=\"translate(2,-3)\" stroke=\"black\" stroke-width=\"5\"/>\n        </g>\n\n      </g>\n      <g class=\"lines\" v-for=\"line in lines\" v-bind:key=\"line.identifier\" >\n        <path v-if=\"line.path\" :d=\"line.path\" :fill=\"line.color\" stroke=\"none\"/>\n        <!--<path v-if=\"line.path\" :d=\"line.path\" :stroke=\"line.color\" fill=\"none\"/>-->\n      </g>\n    </svg>\n\n    <!--brush for x-axis transformation -->\n    <svg :width=\"style.width\" height=\"50\" style=\"background-color: lightgrey\">\n      <g v-if=\"dataState\">\n        <g class=\"lines\" v-for=\"line in lines\" v-bind:key=\"line.identifier\" >\n          <path v-if=\"line.micro\" :d=\"line.micro\" :stroke=\"line.color\" stroke-opacity=\"0.5\" fill=\"none\"/>\n        </g>\n      </g>\n      <g class=\"brush\" />\n    </svg>\n\n\n    <form>\n      <div class=\"form-check\">\n        <input type=\"checkbox\" class=\"form-check-input\" id=\"exampleCheck1\" v-model=\"showContext\" @click=\"showContext = !showContext\">\n        <label class=\"form-check-label\" for=\"exampleCheck1\">Show context</label>\n      </div>\n    </form>\n  </div>\n</template>\n\n<script>\nimport * as d3 from 'd3'\n\n//import { regressionLinear } from 'd3-regression';\n\n\nexport default {\n  data() {\n    return {\n      showContext: true,\n      xDomain: [],\n      style: {\n        width: 1000, //TODO: set to window width\n        height: 300,\n        margin: {\n          top: 25,\n          right: 25,\n          bottom: 0 ,\n          left: 40\n        }\n      },\n    }\n  },\n\n  computed: {\n\n    context: { //get additional information from store\n      cache: false,\n      get: function() {\n        let parseTime = d3.timeParse(\"%Y-%m\");\n        let items = this.$store.getters.getContext.map(item => {\n          item.x = this.scales.x(parseTime(item.date)) //translate date to position\n          return item\n        })\n        return items\n      }\n    },\n\n    //get data from store (this is the computed property \"data\", not vue's data property)\n    data: {\n      cache: false,\n      get: function() {\n        return this.$store.getters.getLines.map(line => {\n          line.touched = 0 //add counter for reactivity when using brush function\n          return line\n        })\n      }\n    },\n\n    //check if every line we received also has data values before we render\n    dataState: function() {\n      let state = false //asume that condition is not met\n      let hasData = this.data.map(line => (line.values) ? true : false) //check if value array exists\n      if(hasData.length > 0 && hasData.every(bool => bool)) state = true //check if all lines have data (and if we have lines at all, otherwise condition for every() would be true)\n      return state\n    },\n\n    //compute scales based on values of all passed lines\n    scales: {\n      cache: true,\n      get() {\n        let parseTime = d3.timeParse(\"%Y-%m\");\n        let style = this.style\n\n        //set range vor all scales on main chart\n        const x = d3.scaleTime().range([style.margin.left,style.width - style.margin.left - style.margin.right]);\n        const y = d3.scaleLinear().range([\n          style.height - style.margin.top - style.margin.bottom,\n          style.margin.bottom\n        ]);\n        const confidence = d3.scaleLinear().range([3,6])\n\n        //set range vor all scales on brushable micro chart\n        const microX = d3.scaleLinear().range([style.margin.left,style.width - style.margin.left - style.margin.right]);\n        const microY = d3.scaleLinear().range([45,5]);\n\n        //bind scales to axes\n        d3.axisLeft().scale(x);\n        d3.axisBottom().scale(y);\n\n        //get minimum and maximum values for each line (i know, it's not elegant :)\n        if(this.dataState) {\n          let arr = []\n          this.data.forEach(line => {\n            line.values.forEach(value => {\n              arr.push(value)\n            })\n          })\n\n          //if this is the first time, get a the xDomain from data, otherwise it has been set by the brush\n          let domain = (this.xDomain.length > 0) ? this.xDomain : d3.extent(arr, d => parseTime(d.d))\n\n          //set domain of all sccales\n          x.domain(domain);\n          microX.domain(d3.extent(arr, d => parseTime(d.d))); //definitely set this to the maximum data domain so we can push it to the limit\n          y.domain(d3.extent(arr, d => +d.r)).nice();\n          microY.domain(d3.extent(arr, d => +d.r));\n          confidence.domain(d3.extent(arr, d => +d.c))\n        }\n\n        return { x, y, microX, microY, confidence };\n      }\n    },\n\n\n    extremeValues: function(){\n      let parseTime = d3.timeParse(\"%Y-%m\");\n      let domain = this.scales.x.domain()\n\n      return this.data.map(line => { //create array for all lines. look in all lines...\n\n        //look for values that are within the visible boundaries of the x-axis\n        let visible = line.values.filter(value => {\n          let date = parseTime(value.d)\n          return (date > domain[0] && date < domain[1]) ? true : false;\n        })\n\n        //form those, get two peaks and two valley values\n        let sorted = visible.sort((a,b) => a.r - b.r)\n        let extreme = sorted.slice(0,2).concat(sorted.slice(sorted.length-2,sorted.length))\n\n        let circles = extreme.map(value => {\n          return {\n            x: this.scales.x(parseTime(value.d)),\n            y: this.scales.y(value.r)\n          }\n        })\n        let obj = {\n          color: line.color,\n          circles: circles\n        }\n        return obj\n      })\n    },\n\n\n    //for each line, compute\n    lines: {\n      cache: false,\n      get: function() {\n        let parseTime = d3.timeParse(\"%Y-%m\");\n\n        //generator for area for main visualization\n         const path = d3.area()\n         .curve(d3.curveBasis) //make curve smooth\n         .x(d => this.scales.x(parseTime(d.d)))\n         //compute two y-values based on confidence() --> number of reviews that produce the average value\n         .y0(d => this.scales.y(d.r)-this.scales.confidence(d.c))\n         .y1(d => this.scales.y(d.r)+this.scales.confidence(d.c));\n\n         /*const path = d3.line()\n         .x(d => this.scales.x(parseTime(d.d)))\n         .y(d => this.scales.y(d.r));*/\n\n         //generator line for brushable micro visualzation\n         const micro = d3.line()\n         .curve(d3.curveBasis)\n         .x(d => this.scales.microX(parseTime(d.d)))\n         .y(d => this.scales.microY(d.r));\n\n         return this.data.map(line => {\n           if(line.values) {\n             //compute paths based on line values\n             line.path = path(line.values)\n             line.micro = micro(line.values)\n           }\n           return line\n         })\n      }\n    },\n  },\n\n\n\n  directives: {\n    axis(el, binding) {//dynamically call and update axis\n      const axis = binding.arg;\n      const axisMethod = { x: \"axisBottom\", y: \"axisLeft\" }[axis];\n      const methodArg = binding.value[axis];\n      d3.select(el).transition().call(d3[axisMethod](methodArg).ticks(5));\n    },\n  },\n\n  watch: {\n    dataState: function(newState) {\n      //TODO: Brush is not initialized when the size is initially loaded. No idea why.\n      if(newState) this.brush() //initialize brush as soon as you have data\n    }\n  },\n\n\n\n  mounted () {\n    this.getWidth()\n    this.$nextTick(function() {\n      window.addEventListener('resize', this.getWidth);\n    })\n  },\n\n  methods: {\n    //initialize brush (dragable selector for x-axis) and add it to DOM\n    brush: function() {\n      const brush = d3.brushX()\n        .extent(this.scales.microX.range().map((e,i) => [e,i*50]))\n        .on(\"end\", this.updateX)\n        //.on(\"brush end\", this.updateX) //update continously while moving (this may result in crap performance)\n\n      d3.select(\"g.brush\")\n        .call(brush)\n        .call(brush.move, this.scales.x.range())\n\n\n    },\n    //scale x-axis of visualization to fit boundaries of brush\n    updateX: function() {\n      let domain = d3.event.selection.map(value => this.scales.microX.invert(value)) //get new domain by getting edges of overlay and translate them to dates\n      domain.forEach((value,i) => {\n        this.$set(this.xDomain,i,value) //iterate over this array to trigger reactivity\n      })\n\n      d3.select(\".xAxes\").transition().call(d3.axisBottom(this.scales.x)) //update Axis\n    },\n\n    getWidth: function() {\n      console.log(\"outer\")\n      if(this.dataState) {\n        console.log(\"dataState\")\n        this.style.width = this.$refs.vis.clientWidth\n      }\n\n      if(this.$refs.vis) console.log(\"refs vis\")\n\n    }\n  }\n\n  /*props: {\n  },\n\n\n\n  created () {\n  },\n\n  methods: {\n  },*/\n}\n</script>\n\n<style scoped>\ndiv {\n  background-color: #F7F7F7;\n}\nsvg.lines {\n  margin-top: 50px;\n  background-color: white;\n}\npath {\n  transition: d .3s\n}\n\n.legend {\n  font-size: 6pt;\n}\n\n.context text {\n  font-size: 10px;\n}\n</style>\n"],"sourceRoot":"src/components"}]}