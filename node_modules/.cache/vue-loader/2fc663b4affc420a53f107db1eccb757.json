{"remainingRequest":"/Users/tk/GitHub/nokia-twin/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/tk/GitHub/nokia-twin/src/components/vis.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/tk/GitHub/nokia-twin/src/components/vis.vue","mtime":1595512426484},{"path":"/Users/tk/GitHub/nokia-twin/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/tk/GitHub/nokia-twin/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/tk/GitHub/nokia-twin/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/tk/GitHub/nokia-twin/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJwoKLy9pbXBvcnQgeyByZWdyZXNzaW9uTGluZWFyIH0gZnJvbSAnZDMtcmVncmVzc2lvbic7CgoKZXhwb3J0IGRlZmF1bHQgewogIGNvbXB1dGVkOiB7CiAgICBzdHlsZTogZnVuY3Rpb24oKSB7CiAgICAgIHJldHVybiB7CiAgICAgICAgd2lkdGg6IDEwMDAsIC8vVE9ETzogc2V0IHRvIHdpbmRvdyB3aWR0aAogICAgICAgIGhlaWdodDogMzAwLAogICAgICAgIG1hcmdpbjogewogICAgICAgICAgdG9wOiAyNSwKICAgICAgICAgIHJpZ2h0OiAyNSwKICAgICAgICAgIGJvdHRvbTogMCAsCiAgICAgICAgICBsZWZ0OiA0MAogICAgICAgIH0KICAgICAgfQogICAgfSwKCiAgICBjb250ZXh0OiB7IC8vZ2V0IGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gZnJvbSBzdG9yZQogICAgICBjYWNoZTogZmFsc2UsCiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgbGV0IHBhcnNlVGltZSA9IGQzLnRpbWVQYXJzZSgiJVktJW0iKTsKICAgICAgICBsZXQgaXRlbXMgPSB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldENvbnRleHQubWFwKGl0ZW0gPT4gewogICAgICAgICAgaXRlbS54ID0gdGhpcy5zY2FsZXMueChwYXJzZVRpbWUoaXRlbS5kYXRlKSkgLy90cmFuc2xhdGUgZGF0ZSB0byBwb3NpdGlvbgogICAgICAgICAgcmV0dXJuIGl0ZW0KICAgICAgICB9KQogICAgICAgIHJldHVybiBpdGVtcwogICAgICB9CiAgICB9LAoKCiAgICBkYXRhOiB7IC8vZ2V0IGRhdGEgZnJvbSBzdG9yZQogICAgICBjYWNoZTogZmFsc2UsCiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZ2V0TGluZXMubWFwKGxpbmUgPT4gewogICAgICAgICAgbGluZS50b3VjaGVkID0gMCAvL2FkZCBjb3VudGVyIGZvciByZWFjdGl2aXR5IHdoZW4gdXNpbmcgYnJ1c2ggZnVuY3Rpb24KICAgICAgICAgIHJldHVybiBsaW5lCiAgICAgICAgfSkKICAgICAgfQogICAgfSwKCiAgICBkYXRhU3RhdGU6IGZ1bmN0aW9uKCkgeyAvL2NoZWNrIGlmIGV2ZXJ5IGxpbmUgd2UgcmVjZWl2ZWQgYWxzbyBoYXMgZGF0YSB2YWx1ZXMgYmVmb3JlIHdlIHJlbmRlcgogICAgICBsZXQgc3RhdGUgPSBmYWxzZSAvL2FzdW1lIHRoYXQgY29uZGl0aW9uIGlzIG5vdCBtZXQKICAgICAgbGV0IGhhc0RhdGEgPSB0aGlzLmRhdGEubWFwKGxpbmUgPT4gKGxpbmUudmFsdWVzKSA/IHRydWUgOiBmYWxzZSkgLy9jaGVjayBpZiB2YWx1ZSBhcnJheSBleGlzdHMKICAgICAgaWYoaGFzRGF0YS5sZW5ndGggPiAwICYmIGhhc0RhdGEuZXZlcnkoYm9vbCA9PiBib29sKSkgc3RhdGUgPSB0cnVlIC8vY2hlY2sgaWYgYWxsIGxpbmVzIGhhdmUgZGF0YSAoYW5kIGlmIHdlIGhhdmUgbGluZXMgYXQgYWxsLCBvdGhlcndpc2UgY29uZGl0aW9uIGZvciBldmVyeSgpIHdvdWxkIGJlIHRydWUpCiAgICAgIHJldHVybiBzdGF0ZQogICAgfSwKCiAgICBzY2FsZXM6IHsvL2NvbXB1dGUgc2NhbGVzCiAgICAgIGNhY2hlOiB0cnVlLAogICAgICBnZXQoKSB7CiAgICAgICAgbGV0IHBhcnNlVGltZSA9IGQzLnRpbWVQYXJzZSgiJVktJW0iKTsKICAgICAgICBsZXQgc3R5bGUgPSB0aGlzLnN0eWxlCgogICAgICAgIGNvbnN0IHdpZHRoID0gZDMuc2NhbGVMaW5lYXIoKS5yYW5nZShbMyw2XSkKICAgICAgICBjb25zdCB4ID0gZDMuc2NhbGVUaW1lKCkucmFuZ2UoW3N0eWxlLm1hcmdpbi5sZWZ0LHN0eWxlLndpZHRoIC0gc3R5bGUubWFyZ2luLmxlZnQgLSBzdHlsZS5tYXJnaW4ucmlnaHRdKTsKICAgICAgICBjb25zdCB5ID0gZDMuc2NhbGVMaW5lYXIoKS5yYW5nZShbCiAgICAgICAgICBzdHlsZS5oZWlnaHQgLSBzdHlsZS5tYXJnaW4udG9wIC0gc3R5bGUubWFyZ2luLmJvdHRvbSwKICAgICAgICAgIHN0eWxlLm1hcmdpbi5ib3R0b20KICAgICAgICBdKTsKICAgICAgICBjb25zdCBtaWNyb1kgPSBkMy5zY2FsZUxpbmVhcigpLnJhbmdlKFs0NSw1XSk7CiAgICAgICAgY29uc3QgbWljcm9YID0gZDMuc2NhbGVMaW5lYXIoKS5yYW5nZShbc3R5bGUubWFyZ2luLmxlZnQsc3R5bGUud2lkdGggLSBzdHlsZS5tYXJnaW4ubGVmdCAtIHN0eWxlLm1hcmdpbi5yaWdodF0pOwoKICAgICAgICBkMy5heGlzTGVmdCgpLnNjYWxlKHgpOwogICAgICAgIGQzLmF4aXNCb3R0b20oKS5zY2FsZSh5KTsKCiAgICAgICAgaWYodGhpcy5kYXRhU3RhdGUpIHsKICAgICAgICAgIGxldCBhcnIgPSBbXSAvL25vdCBlbGVnYW50LCBidXQgZWFzaWVzdCB3YXkgdG8gZmluZCBleHRyZW1lIHZhbHVlcyBhY3Jvc3MgYWxsIGxpbmVzCiAgICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaChsaW5lID0+IHsKICAgICAgICAgICAgbGluZS52YWx1ZXMuZm9yRWFjaCh2YWx1ZSA9PiB7CiAgICAgICAgICAgICAgYXJyLnB1c2godmFsdWUpCiAgICAgICAgICAgIH0pCiAgICAgICAgICB9KQoKICAgICAgICAgIGxldCBkb21haW4gPSAodGhpcy54RG9tYWluLmxlbmd0aCA+IDApID8gdGhpcy54RG9tYWluIDogZDMuZXh0ZW50KGFyciwgZCA9PiBwYXJzZVRpbWUoZC5kKSkgLy9pZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lLCBnZXQgYSB0aGUgeERvbWFpbiBmcm9tIGRhdGEsIG90aGVyd2lzZSBpdCBoYXMgYmVlbiBzZXQgYnkgdGhlIGJydXNoCgogICAgICAgICAgeC5kb21haW4oZG9tYWluKTsKICAgICAgICAgIG1pY3JvWC5kb21haW4oZDMuZXh0ZW50KGFyciwgZCA9PiBwYXJzZVRpbWUoZC5kKSkpOyAvL2RlZmluaXRlbHkgc2V0IHRoaXMgdG8gdGhlIG1heGltdW0gZGF0YSBkb21haW4gc28gd2UgY2FuIHB1c2ggaXQgdG8gdGhlIGxpbWl0CiAgICAgICAgICB5LmRvbWFpbihkMy5leHRlbnQoYXJyLCBkID0+ICtkLnIpKTsKICAgICAgICAgIG1pY3JvWS5kb21haW4oZDMuZXh0ZW50KGFyciwgZCA9PiArZC5yKSk7CiAgICAgICAgICB3aWR0aC5kb21haW4oZDMuZXh0ZW50KGFyciwgZCA9PiArZC5jKSkKICAgICAgICB9CgogICAgICAgIHJldHVybiB7IHgsIHksIG1pY3JvWCwgbWljcm9ZLCB3aWR0aCB9OwogICAgICB9CiAgICB9LAoKCgogICAgbGluZXM6IHsKICAgICAgY2FjaGU6IGZhbHNlLAogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIGxldCBwYXJzZVRpbWUgPSBkMy50aW1lUGFyc2UoIiVZLSVtIik7CiAgICAgICAgIGNvbnN0IHBhdGggPSBkMy5hcmVhKCkKICAgICAgICAgLmN1cnZlKGQzLmN1cnZlQmFzaXMpCiAgICAgICAgIC54MChkID0+IHRoaXMuc2NhbGVzLngocGFyc2VUaW1lKGQuZCkpLXRoaXMuc2NhbGVzLndpZHRoKGQuYykgLzMpCiAgICAgICAgIC54MShkID0+IHRoaXMuc2NhbGVzLngocGFyc2VUaW1lKGQuZCkpK3RoaXMuc2NhbGVzLndpZHRoKGQuYykgLzMpCiAgICAgICAgIC8vLngwKGQgPT4gdGhpcy5zY2FsZXMueChwYXJzZVRpbWUoZC5kKS10aGlzLnNjYWxlcy53aWR0aChkLmMpKSkKICAgICAgICAgLy8ueDEoZCA9PiB0aGlzLnNjYWxlcy54KHBhcnNlVGltZShkLmQpK3RoaXMuc2NhbGVzLndpZHRoKGQuYykpKQogICAgICAgICAueTAoZCA9PiB0aGlzLnNjYWxlcy55KGQuciktdGhpcy5zY2FsZXMud2lkdGgoZC5jKSkKICAgICAgICAgLnkxKGQgPT4gdGhpcy5zY2FsZXMueShkLnIpK3RoaXMuc2NhbGVzLndpZHRoKGQuYykpOwoKICAgICAgICAgLypjb25zdCBwYXRoID0gZDMubGluZSgpCiAgICAgICAgIC54KGQgPT4gdGhpcy5zY2FsZXMueChwYXJzZVRpbWUoZC5kKSkpCiAgICAgICAgIC55KGQgPT4gdGhpcy5zY2FsZXMueShkLnIpKTsqLwoKICAgICAgICAgY29uc3QgbWljcm8gPSBkMy5saW5lKCkKICAgICAgICAgLmN1cnZlKGQzLmN1cnZlQmFzaXMpCiAgICAgICAgIC54KGQgPT4gdGhpcy5zY2FsZXMubWljcm9YKHBhcnNlVGltZShkLmQpKSkKICAgICAgICAgLnkoZCA9PiB0aGlzLnNjYWxlcy5taWNyb1koZC5yKSk7CgogICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChsaW5lID0+IHsKICAgICAgICAgICBpZihsaW5lLnZhbHVlcykgewogICAgICAgICAgICAgbGluZS5wYXRoID0gcGF0aChsaW5lLnZhbHVlcykKICAgICAgICAgICAgIGxpbmUubWljcm8gPSBtaWNybyhsaW5lLnZhbHVlcykKICAgICAgICAgICB9CiAgICAgICAgICAgLy9pZihsaW5lLnZhbHVlcykgbGluZS5yZWdMaW5lID0gcmVnKGxpbmUudmFsdWVzKQogICAgICAgICAgIHJldHVybiBsaW5lCiAgICAgICAgIH0pCiAgICAgIH0KICAgIH0sCiAgfSwKCgoKICBkaXJlY3RpdmVzOiB7CiAgICBheGlzKGVsLCBiaW5kaW5nKSB7Ly9keW5hbWljYWxseSBjYWxsIGFuZCB1cGRhdGUgYXhpcwoKICAgICAgLy9sZXQgcGFyc2VUaW1lID0gZDMudGltZVBhcnNlKCIlWS0lbSIpOwogICAgICBjb25zdCBheGlzID0gYmluZGluZy5hcmc7CiAgICAgIGNvbnN0IGF4aXNNZXRob2QgPSB7IHg6ICJheGlzQm90dG9tIiwgeTogImF4aXNMZWZ0IiB9W2F4aXNdOwogICAgICBjb25zdCBtZXRob2RBcmcgPSBiaW5kaW5nLnZhbHVlW2F4aXNdOwogICAgICBkMy5zZWxlY3QoZWwpLnRyYW5zaXRpb24oKS5jYWxsKGQzW2F4aXNNZXRob2RdKG1ldGhvZEFyZykudGlja3MoNSkpOwogICAgfSwKICB9LAoKICB3YXRjaDogewogICAgZGF0YVN0YXRlOiBmdW5jdGlvbihuZXdTdGF0ZSkgewoKICAgICAgaWYobmV3U3RhdGUpIHRoaXMuYnJ1c2goKSAvL2luaXRpYWxpemUgYnJ1c2ggYXMgc29vbiBhcyB5b3UgaGF2ZSBkYXRhCiAgICB9CiAgfSwKCgoKICBtb3VudGVkICgpIHsKICAgIC8vaWYodGhpcy5kYXRhU3RhdGUpIHRoaXMuYnJ1c2goKSAvL2luaXRpYWxpemUgYnJ1c2ggaWYgeW91IGdvdCBkYXRhCiAgfSwKCiAgZGF0YSgpIHsKICAgIHJldHVybiB7CiAgICAgIHNob3dDb250ZXh0OiB0cnVlLAogICAgICB4RG9tYWluOiBbXQogICAgfQogIH0sCgogIG1ldGhvZHM6IHsKICAgIGJydXNoOiBmdW5jdGlvbigpIHsKICAgICAgY29uc3QgYnJ1c2ggPSBkMy5icnVzaFgoKQogICAgICAgIC5leHRlbnQodGhpcy5zY2FsZXMubWljcm9YLnJhbmdlKCkubWFwKChlLGkpID0+IFtlLGkqNTBdKSkKICAgICAgICAub24oImJydXNoIiwgdGhpcy51cGRhdGVYKQoKICAgICAgZDMuc2VsZWN0KCJnLmJydXNoIikKICAgICAgICAuY2FsbChicnVzaCkKICAgICAgICAuY2FsbChicnVzaC5tb3ZlLCB0aGlzLnNjYWxlcy54LnJhbmdlKCkpCgoKICAgIH0sCiAgICB1cGRhdGVYOiBmdW5jdGlvbigpIHsKICAgICAgLy9UT0RPIGRvbWFpbiBzZWVtcyB0byB3b3JrLCBidXQgdXNlcyBpbmV4aWNhYmx5IGhpZ2ggdmFsdWVzCiAgICAgIGxldCBkb21haW4gPSBkMy5ldmVudC5zZWxlY3Rpb24ubWFwKHZhbHVlID0+IHRoaXMuc2NhbGVzLm1pY3JvWC5pbnZlcnQodmFsdWUpKSAvL2dldCBuZXcgZG9tYWluIGJ5IGdldHRpbmcgZWRnZXMgb2Ygb3ZlcmxheSBhbmQgdHJhbnNsYXRlIHRoZW0gdG8gZGF0ZXMKICAgICAgZG9tYWluLmZvckVhY2goKHZhbHVlLGkpID0+IHsKICAgICAgICB2YWx1ZQogICAgICAgIHRoaXMuJHNldCh0aGlzLnhEb21haW4saSx2YWx1ZSkgLy9pdGVyYXRlIG92ZXIgdGhpcyBhcnJheSB0byB0cmlnZ2VyIHJlYWN0aXZpdHkKICAgICAgfSkKCiAgICAgIGQzLnNlbGVjdCgiLnhBeGVzIikudHJhbnNpdGlvbigpLmNhbGwoZDMuYXhpc0JvdHRvbSh0aGlzLnNjYWxlcy54KSkgLy91cGRhdGUgQXhpcwoKICAgIH0KICB9CgogIC8qcHJvcHM6IHsKICB9LAoKCgogIGNyZWF0ZWQgKCkgewogIH0sCgogIG1ldGhvZHM6IHsKICB9LCovCn0K"},{"version":3,"sources":["vis.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqDA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA","file":"vis.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"col-9\">\n    <!--<div v-if=\"dataState\">\n      <div v-for=\"(line,index) in lines\" v-bind:key=\"index\">{{line.query}}</div>\n    </div>-->\n    <svg :width=\"style.width\" :height=\"style.height\" v-if=\"dataState\" class=\"lines\">\n      <g class=\"axes\">\n        <g v-axis:x=\"scales\" class=\"xAxes\" :transform=\"`translate(0,${style.height-style.margin.top-style.margin.bottom})`\"></g>\n        <g v-axis:y=\"scales\" class=\"yAxes\" :transform=\"`translate(${style.margin.left},0)`\"></g>\n      </g>\n      <g class=\"context\" v-if=\"showContext\">\n        <g v-for=\"(item, index) in context\" :key=\"`context-${index}`\" :transform=\"`translate(${item.x},0)`\">\n          <line x1=\"0\" x2=\"0\" :y1=\"style.margin.top\" :y2=\"style.height-style.margin.bottom-style.margin.top\" stroke=\"black\" stroke-dasharray=\"4\" />\n          <text x=\"10\" :y=\"style.margin.top+20\">{{item.text}}</text>\n        </g>\n      </g>\n      <g class=\"legend\" :transform=\"`translate(${style.width-style.margin.right-50},${style.height-style.margin.bottom-50})`\">\n        <g>\n          <text text-anchor=\"end\">less confident</text>\n          <line x0=\"0\" x1=\"20\" y0=\"0\" y1=\"0\" transform=\"translate(2,-3)\" stroke=\"black\" stroke-width=\"2\"/>\n        </g>\n        <g transform=\"translate(0,10)\">\n          <text text-anchor=\"end\">more confident</text>\n          <line x0=\"0\" x1=\"20\" y0=\"0\" y1=\"0\" transform=\"translate(2,-3)\" stroke=\"black\" stroke-width=\"5\"/>\n        </g>\n\n      </g>\n      <g class=\"lines\" v-for=\"line in lines\" v-bind:key=\"line.identifier\" >\n        <path v-if=\"line.path\" :d=\"line.path\" :fill=\"line.color\" stroke=\"none\"/>\n        <!--<path v-if=\"line.path\" :d=\"line.path\" :stroke=\"line.color\" fill=\"none\"/>-->\n      </g>\n    </svg>\n\n    <svg :width=\"style.width\" height=\"50\" style=\"background-color: lightgrey\">\n      <g v-if=\"dataState\">\n        <g class=\"lines\" v-for=\"line in lines\" v-bind:key=\"line.identifier\" >\n          <path v-if=\"line.micro\" :d=\"line.micro\" :stroke=\"line.color\" stroke-opacity=\"0.5\" fill=\"none\"/>\n        </g>\n      </g>\n      <g class=\"brush\" />\n    </svg>\n\n\n    <form>\n      <div class=\"form-check\">\n        <input type=\"checkbox\" class=\"form-check-input\" id=\"exampleCheck1\" v-model=\"showContext\" @click=\"showContext = !showContext\">\n        <label class=\"form-check-label\" for=\"exampleCheck1\">Show context</label>\n      </div>\n    </form>\n  </div>\n</template>\n\n<script>\nimport * as d3 from 'd3'\n\n//import { regressionLinear } from 'd3-regression';\n\n\nexport default {\n  computed: {\n    style: function() {\n      return {\n        width: 1000, //TODO: set to window width\n        height: 300,\n        margin: {\n          top: 25,\n          right: 25,\n          bottom: 0 ,\n          left: 40\n        }\n      }\n    },\n\n    context: { //get additional information from store\n      cache: false,\n      get: function() {\n        let parseTime = d3.timeParse(\"%Y-%m\");\n        let items = this.$store.getters.getContext.map(item => {\n          item.x = this.scales.x(parseTime(item.date)) //translate date to position\n          return item\n        })\n        return items\n      }\n    },\n\n\n    data: { //get data from store\n      cache: false,\n      get: function() {\n        return this.$store.getters.getLines.map(line => {\n          line.touched = 0 //add counter for reactivity when using brush function\n          return line\n        })\n      }\n    },\n\n    dataState: function() { //check if every line we received also has data values before we render\n      let state = false //asume that condition is not met\n      let hasData = this.data.map(line => (line.values) ? true : false) //check if value array exists\n      if(hasData.length > 0 && hasData.every(bool => bool)) state = true //check if all lines have data (and if we have lines at all, otherwise condition for every() would be true)\n      return state\n    },\n\n    scales: {//compute scales\n      cache: true,\n      get() {\n        let parseTime = d3.timeParse(\"%Y-%m\");\n        let style = this.style\n\n        const width = d3.scaleLinear().range([3,6])\n        const x = d3.scaleTime().range([style.margin.left,style.width - style.margin.left - style.margin.right]);\n        const y = d3.scaleLinear().range([\n          style.height - style.margin.top - style.margin.bottom,\n          style.margin.bottom\n        ]);\n        const microY = d3.scaleLinear().range([45,5]);\n        const microX = d3.scaleLinear().range([style.margin.left,style.width - style.margin.left - style.margin.right]);\n\n        d3.axisLeft().scale(x);\n        d3.axisBottom().scale(y);\n\n        if(this.dataState) {\n          let arr = [] //not elegant, but easiest way to find extreme values across all lines\n          this.data.forEach(line => {\n            line.values.forEach(value => {\n              arr.push(value)\n            })\n          })\n\n          let domain = (this.xDomain.length > 0) ? this.xDomain : d3.extent(arr, d => parseTime(d.d)) //if this is the first time, get a the xDomain from data, otherwise it has been set by the brush\n\n          x.domain(domain);\n          microX.domain(d3.extent(arr, d => parseTime(d.d))); //definitely set this to the maximum data domain so we can push it to the limit\n          y.domain(d3.extent(arr, d => +d.r));\n          microY.domain(d3.extent(arr, d => +d.r));\n          width.domain(d3.extent(arr, d => +d.c))\n        }\n\n        return { x, y, microX, microY, width };\n      }\n    },\n\n\n\n    lines: {\n      cache: false,\n      get: function() {\n        let parseTime = d3.timeParse(\"%Y-%m\");\n         const path = d3.area()\n         .curve(d3.curveBasis)\n         .x0(d => this.scales.x(parseTime(d.d))-this.scales.width(d.c) /3)\n         .x1(d => this.scales.x(parseTime(d.d))+this.scales.width(d.c) /3)\n         //.x0(d => this.scales.x(parseTime(d.d)-this.scales.width(d.c)))\n         //.x1(d => this.scales.x(parseTime(d.d)+this.scales.width(d.c)))\n         .y0(d => this.scales.y(d.r)-this.scales.width(d.c))\n         .y1(d => this.scales.y(d.r)+this.scales.width(d.c));\n\n         /*const path = d3.line()\n         .x(d => this.scales.x(parseTime(d.d)))\n         .y(d => this.scales.y(d.r));*/\n\n         const micro = d3.line()\n         .curve(d3.curveBasis)\n         .x(d => this.scales.microX(parseTime(d.d)))\n         .y(d => this.scales.microY(d.r));\n\n         return this.data.map(line => {\n           if(line.values) {\n             line.path = path(line.values)\n             line.micro = micro(line.values)\n           }\n           //if(line.values) line.regLine = reg(line.values)\n           return line\n         })\n      }\n    },\n  },\n\n\n\n  directives: {\n    axis(el, binding) {//dynamically call and update axis\n\n      //let parseTime = d3.timeParse(\"%Y-%m\");\n      const axis = binding.arg;\n      const axisMethod = { x: \"axisBottom\", y: \"axisLeft\" }[axis];\n      const methodArg = binding.value[axis];\n      d3.select(el).transition().call(d3[axisMethod](methodArg).ticks(5));\n    },\n  },\n\n  watch: {\n    dataState: function(newState) {\n\n      if(newState) this.brush() //initialize brush as soon as you have data\n    }\n  },\n\n\n\n  mounted () {\n    //if(this.dataState) this.brush() //initialize brush if you got data\n  },\n\n  data() {\n    return {\n      showContext: true,\n      xDomain: []\n    }\n  },\n\n  methods: {\n    brush: function() {\n      const brush = d3.brushX()\n        .extent(this.scales.microX.range().map((e,i) => [e,i*50]))\n        .on(\"brush\", this.updateX)\n\n      d3.select(\"g.brush\")\n        .call(brush)\n        .call(brush.move, this.scales.x.range())\n\n\n    },\n    updateX: function() {\n      //TODO domain seems to work, but uses inexicably high values\n      let domain = d3.event.selection.map(value => this.scales.microX.invert(value)) //get new domain by getting edges of overlay and translate them to dates\n      domain.forEach((value,i) => {\n        value\n        this.$set(this.xDomain,i,value) //iterate over this array to trigger reactivity\n      })\n\n      d3.select(\".xAxes\").transition().call(d3.axisBottom(this.scales.x)) //update Axis\n\n    }\n  }\n\n  /*props: {\n  },\n\n\n\n  created () {\n  },\n\n  methods: {\n  },*/\n}\n</script>\n\n<style scoped>\ndiv {\n  background-color: #F7F7F7;\n}\nsvg.lines {\n  margin-top: 50px;\n  background-color: white;\n}\npath {\n  transition: d .3s\n}\n\n.legend {\n  font-size: 6pt;\n}\n\n.context text {\n  font-size: 10px;\n}\n</style>\n"]}]}