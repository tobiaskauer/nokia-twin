{"remainingRequest":"/Users/tk/GitHub/nokiatwin/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/tk/GitHub/nokiatwin/src/components/vis.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/tk/GitHub/nokiatwin/src/components/vis.vue","mtime":1605532590285},{"path":"/Users/tk/GitHub/nokiatwin/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/tk/GitHub/nokiatwin/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/tk/GitHub/nokiatwin/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/tk/GitHub/nokiatwin/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJwoKLy9pbXBvcnQgeyByZWdyZXNzaW9uTGluZWFyIH0gZnJvbSAnZDMtcmVncmVzc2lvbic7CgoKZXhwb3J0IGRlZmF1bHQgewogIGRhdGEoKSB7CiAgICByZXR1cm4gewogICAgICBzaG93RXZlbnRzOiB0cnVlLAogICAgICBjdXJyZW50RXZlbnQ6IHt9LAogICAgICB4RG9tYWluOiBbXSwKICAgICAgbGluZVRoaWNrbmVzczogWzMsMTBdLAogICAgICBzdHlsZTogewogICAgICAgIHdpZHRoOiAxMDAwLCAvL1RPRE86IHNldCB0byB3aW5kb3cgd2lkdGgKICAgICAgICBoZWlnaHQ6IDMwMCwKICAgICAgICBtYXJnaW46IHsKICAgICAgICAgIHRvcDogMzAsCiAgICAgICAgICByaWdodDogMjUsCiAgICAgICAgICBib3R0b206IDAgLAogICAgICAgICAgbGVmdDogNDAKICAgICAgICB9CiAgICAgIH0sCiAgICB9CiAgfSwKCiAgY29tcHV0ZWQ6IHsKICAgIGV2ZW50czogeyAvL2dldCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZyb20gc3RvcmUKICAgICAgY2FjaGU6IHRydWUsCiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgbGV0IHBhcnNlVGltZSA9IGQzLnRpbWVQYXJzZSgiJWQtJW0tJVkiKTsKICAgICAgICBsZXQgZXZlbnRzID0gdGhpcy4kc3RvcmUuc3RhdGUuZXZlbnRzLm1hcChldmVudCA9PiB7CiAgICAgICAgICBldmVudC54ID0gdGhpcy5zY2FsZXMueChwYXJzZVRpbWUoZXZlbnQuZGF0ZSkpIC8vdHJhbnNsYXRlIGRhdGUgdG8gcG9zaXRpb24KICAgICAgICAgIHJldHVybiBldmVudAogICAgICAgIH0pCiAgICAgICAgcmV0dXJuIGV2ZW50cwogICAgICB9CiAgICB9LAoKICAgIGFjdGl2ZU1ldHJpYzogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZ2V0QWN0aXZlTWV0cmljfSwKCiAgICAvL2dldCBkYXRhIGZyb20gc3RvcmUgKHRoaXMgaXMgdGhlIGNvbXB1dGVkIHByb3BlcnR5ICJkYXRhIiwgbm90IHZ1ZSdzIGRhdGEgcHJvcGVydHkpCiAgICBkYXRhOiB7CiAgICAgIGNhY2hlOiBmYWxzZSwKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRMaW5lcy5tYXAobGluZSA9PiB7CiAgICAgICAgICBsaW5lLnRvdWNoZWQgPSAwIC8vYWRkIGNvdW50ZXIgZm9yIHJlYWN0aXZpdHkgd2hlbiB1c2luZyBicnVzaCBmdW5jdGlvbgogICAgICAgICAgcmV0dXJuIGxpbmUKICAgICAgICB9KQogICAgICB9CiAgICB9LAoKICAgIC8vY2hlY2sgaWYgZXZlcnkgbGluZSB3ZSByZWNlaXZlZCBhbHNvIGhhcyBkYXRhIHZhbHVlcyBiZWZvcmUgd2UgcmVuZGVyCiAgICBkYXRhU3RhdGU6IGZ1bmN0aW9uKCkgewogICAgICBsZXQgc3RhdGUgPSBmYWxzZSAvL2FzdW1lIHRoYXQgY29uZGl0aW9uIGlzIG5vdCBtZXQKICAgICAgbGV0IGhhc0RhdGEgPSB0aGlzLmRhdGEubWFwKGxpbmUgPT4gKGxpbmUudmFsdWVzKSA/IHRydWUgOiBmYWxzZSkgLy9jaGVjayBpZiB2YWx1ZSBhcnJheSBleGlzdHMKICAgICAgaWYoaGFzRGF0YS5sZW5ndGggPiAwICYmIGhhc0RhdGEuZXZlcnkoYm9vbCA9PiBib29sKSkgc3RhdGUgPSB0cnVlIC8vY2hlY2sgaWYgYWxsIGxpbmVzIGhhdmUgZGF0YSAoYW5kIGlmIHdlIGhhdmUgbGluZXMgYXQgYWxsLCBvdGhlcndpc2UgY29uZGl0aW9uIGZvciBldmVyeSgpIHdvdWxkIGJlIHRydWUpCiAgICAgIHJldHVybiBzdGF0ZQogICAgfSwKCiAgICAvL2NvbXB1dGUgc2NhbGVzIGJhc2VkIG9uIHZhbHVlcyBvZiBhbGwgcGFzc2VkIGxpbmVzCiAgICBzY2FsZXM6IHsKICAgICAgY2FjaGU6IHRydWUsCiAgICAgIGdldCgpIHsKICAgICAgICBsZXQgcGFyc2VUaW1lID0gZDMudGltZVBhcnNlKCIlWS0lbSIpOwogICAgICAgIGxldCBzdHlsZSA9IHRoaXMuc3R5bGUKCiAgICAgICAgLy9zZXQgcmFuZ2Ugdm9yIGFsbCBzY2FsZXMgb24gbWFpbiBjaGFydAogICAgICAgIGNvbnN0IHggPSBkMy5zY2FsZVRpbWUoKS5yYW5nZShbc3R5bGUubWFyZ2luLmxlZnQsc3R5bGUud2lkdGggLSBzdHlsZS5tYXJnaW4ubGVmdCAtIHN0eWxlLm1hcmdpbi5yaWdodF0pOwogICAgICAgIGNvbnN0IHkgPSBkMy5zY2FsZUxpbmVhcigpLnJhbmdlKFsKICAgICAgICAgIHN0eWxlLmhlaWdodCAtIHN0eWxlLm1hcmdpbi50b3AgLSBzdHlsZS5tYXJnaW4uYm90dG9tLAogICAgICAgICAgc3R5bGUubWFyZ2luLmJvdHRvbQogICAgICAgIF0pOwogICAgICAgIGNvbnN0IGNvbmZpZGVuY2UgPSBkMy5zY2FsZUxpbmVhcigpLnJhbmdlKHRoaXMubGluZVRoaWNrbmVzcykKCiAgICAgICAgLy9zZXQgcmFuZ2Ugdm9yIGFsbCBzY2FsZXMgb24gYnJ1c2hhYmxlIG1pY3JvIGNoYXJ0CiAgICAgICAgY29uc3QgbWljcm9YID0gZDMuc2NhbGVMaW5lYXIoKS5yYW5nZShbc3R5bGUubWFyZ2luLmxlZnQsc3R5bGUud2lkdGggLSBzdHlsZS5tYXJnaW4ubGVmdCAtIHN0eWxlLm1hcmdpbi5yaWdodF0pOwogICAgICAgIGNvbnN0IG1pY3JvWSA9IGQzLnNjYWxlTGluZWFyKCkucmFuZ2UoWzQ1LDVdKTsKCiAgICAgICAgLy9iaW5kIHNjYWxlcyB0byBheGVzCiAgICAgICAgZDMuYXhpc0xlZnQoKS5zY2FsZSh4KTsKICAgICAgICBkMy5heGlzQm90dG9tKCkuc2NhbGUoeSk7CgogICAgICAgIC8vZ2V0IG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzIGZvciBlYWNoIGxpbmUgKGkga25vdywgaXQncyBub3QgZWxlZ2FudCA6KQogICAgICAgIGlmKHRoaXMuZGF0YVN0YXRlKSB7CiAgICAgICAgICBsZXQgYXJyID0gW10KICAgICAgICAgIHRoaXMuZGF0YS5mb3JFYWNoKGxpbmUgPT4gewogICAgICAgICAgICBsaW5lLnZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHsKICAgICAgICAgICAgICBhcnIucHVzaCh2YWx1ZSkKICAgICAgICAgICAgfSkKICAgICAgICAgIH0pCgogICAgICAgICAgLy9pZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lLCBnZXQgYSB0aGUgeERvbWFpbiBmcm9tIGRhdGEsIG90aGVyd2lzZSBpdCBoYXMgYmVlbiBzZXQgYnkgdGhlIGJydXNoCiAgICAgICAgICBsZXQgZG9tYWluID0gKHRoaXMueERvbWFpbi5sZW5ndGggPiAwKSA/IHRoaXMueERvbWFpbiA6IGQzLmV4dGVudChhcnIsIGQgPT4gcGFyc2VUaW1lKGQuZCkpCgogICAgICAgICAgLy9zZXQgZG9tYWluIG9mIGFsbCBzY2NhbGVzCiAgICAgICAgICB4LmRvbWFpbihkb21haW4pOwogICAgICAgICAgbWljcm9YLmRvbWFpbihkMy5leHRlbnQoYXJyLCBkID0+IHBhcnNlVGltZShkLmQpKSk7IC8vZGVmaW5pdGVseSBzZXQgdGhpcyB0byB0aGUgbWF4aW11bSBkYXRhIGRvbWFpbiBzbyB3ZSBjYW4gcHVzaCBpdCB0byB0aGUgbGltaXQKICAgICAgICAgIHkuZG9tYWluKGQzLmV4dGVudChhcnIsIGQgPT4gK2QucikpLm5pY2UoKTsKICAgICAgICAgIG1pY3JvWS5kb21haW4oZDMuZXh0ZW50KGFyciwgZCA9PiArZC5yKSk7CiAgICAgICAgICBjb25maWRlbmNlLmRvbWFpbihkMy5leHRlbnQoYXJyLCBkID0+ICtkLmMpKQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIHsgeCwgeSwgbWljcm9YLCBtaWNyb1ksIGNvbmZpZGVuY2UgfTsKICAgICAgfQogICAgfSwKCgogICAgLypleHRyZW1lVmFsdWVzOiBmdW5jdGlvbigpewogICAgICBsZXQgcGFyc2VUaW1lID0gZDMudGltZVBhcnNlKCIlWS0lbSIpOwogICAgICBsZXQgZG9tYWluID0gdGhpcy5zY2FsZXMueC5kb21haW4oKQoKICAgICAgcmV0dXJuIHRoaXMuZGF0YS5tYXAobGluZSA9PiB7IC8vY3JlYXRlIGFycmF5IGZvciBhbGwgbGluZXMuIGxvb2sgaW4gYWxsIGxpbmVzLi4uCgogICAgICAgIC8vbG9vayBmb3IgdmFsdWVzIHRoYXQgYXJlIHdpdGhpbiB0aGUgdmlzaWJsZSBib3VuZGFyaWVzIG9mIHRoZSB4LWF4aXMKICAgICAgICBsZXQgdmlzaWJsZSA9IGxpbmUudmFsdWVzLmZpbHRlcih2YWx1ZSA9PiB7CiAgICAgICAgICBsZXQgZGF0ZSA9IHBhcnNlVGltZSh2YWx1ZS5kKQogICAgICAgICAgcmV0dXJuIChkYXRlID4gZG9tYWluWzBdICYmIGRhdGUgPCBkb21haW5bMV0pID8gdHJ1ZSA6IGZhbHNlOwogICAgICAgIH0pCgogICAgICAgIC8vZm9ybSB0aG9zZSwgZ2V0IHR3byBwZWFrcyBhbmQgdHdvIHZhbGxleSB2YWx1ZXMKICAgICAgICBsZXQgc29ydGVkID0gdmlzaWJsZS5zb3J0KChhLGIpID0+IGEuciAtIGIucikKICAgICAgICBsZXQgZXh0cmVtZSA9IHNvcnRlZC5zbGljZSgwLDIpLmNvbmNhdChzb3J0ZWQuc2xpY2Uoc29ydGVkLmxlbmd0aC0yLHNvcnRlZC5sZW5ndGgpKQoKICAgICAgICBsZXQgY2lyY2xlcyA9IGV4dHJlbWUubWFwKHZhbHVlID0+IHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIHg6IHRoaXMuc2NhbGVzLngocGFyc2VUaW1lKHZhbHVlLmQpKSwKICAgICAgICAgICAgeTogdGhpcy5zY2FsZXMueSh2YWx1ZS5yKQogICAgICAgICAgfQogICAgICAgIH0pCiAgICAgICAgbGV0IG9iaiA9IHsKICAgICAgICAgIGNvbG9yOiBsaW5lLmNvbG9yLAogICAgICAgICAgY2lyY2xlczogY2lyY2xlcwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2JqCiAgICAgIH0pCiAgICB9LCovCgoKICAgIC8vZm9yIGVhY2ggbGluZSwgY29tcHV0ZSB0aGUgYWN0dWFsIHBsb3QKICAgIGxpbmVzOiB7CiAgICAgIGNhY2hlOiBmYWxzZSwKICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICBsZXQgcGFyc2VUaW1lID0gZDMudGltZVBhcnNlKCIlWS0lbSIpOwoKICAgICAgICAvL2dlbmVyYXRvciBmb3IgYXJlYSBmb3IgbWFpbiB2aXN1YWxpemF0aW9uCiAgICAgICAgIGNvbnN0IHBhdGggPSBkMy5hcmVhKCkKICAgICAgICAgLmN1cnZlKGQzLmN1cnZlQmFzaXMpIC8vbWFrZSBjdXJ2ZSBzbW9vdGgKICAgICAgICAgLngoZCA9PiB0aGlzLnNjYWxlcy54KHBhcnNlVGltZShkLmQpKSkKICAgICAgICAgLy9jb21wdXRlIHR3byB5LXZhbHVlcyBiYXNlZCBvbiBjb25maWRlbmNlKCkgLS0+IG51bWJlciBvZiByZXZpZXdzIHRoYXQgcHJvZHVjZSB0aGUgYXZlcmFnZSB2YWx1ZQogICAgICAgICAueTAoZCA9PiB0aGlzLnNjYWxlcy55KGQuciktdGhpcy5zY2FsZXMuY29uZmlkZW5jZShkLmMpKQogICAgICAgICAueTEoZCA9PiB0aGlzLnNjYWxlcy55KGQucikrdGhpcy5zY2FsZXMuY29uZmlkZW5jZShkLmMpKTsKCiAgICAgICAgIC8qY29uc3QgcGF0aCA9IGQzLmxpbmUoKQogICAgICAgICAueChkID0+IHRoaXMuc2NhbGVzLngocGFyc2VUaW1lKGQuZCkpKQogICAgICAgICAueShkID0+IHRoaXMuc2NhbGVzLnkoZC5yKSk7Ki8KCiAgICAgICAgIC8vZ2VuZXJhdG9yIGxpbmUgZm9yIGJydXNoYWJsZSBtaWNybyB2aXN1YWx6YXRpb24KICAgICAgICAgY29uc3QgbWljcm8gPSBkMy5saW5lKCkKICAgICAgICAgLmN1cnZlKGQzLmN1cnZlQmFzaXMpCiAgICAgICAgIC54KGQgPT4gdGhpcy5zY2FsZXMubWljcm9YKHBhcnNlVGltZShkLmQpKSkKICAgICAgICAgLnkoZCA9PiB0aGlzLnNjYWxlcy5taWNyb1koZC5yKSk7CgogICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChsaW5lID0+IHsKICAgICAgICAgICBpZihsaW5lLnZhbHVlcykgewogICAgICAgICAgICAgLy9jb21wdXRlIHBhdGhzIGJhc2VkIG9uIGxpbmUgdmFsdWVzCiAgICAgICAgICAgICBsaW5lLnBhdGggPSBwYXRoKGxpbmUudmFsdWVzKQogICAgICAgICAgICAgbGluZS5taWNybyA9IG1pY3JvKGxpbmUudmFsdWVzKQogICAgICAgICAgIH0KICAgICAgICAgICByZXR1cm4gbGluZQogICAgICAgICB9KQogICAgICB9CiAgICB9LAogIH0sCgoKCiAgZGlyZWN0aXZlczogewogICAgYXhpcyhlbCwgYmluZGluZykgey8vZHluYW1pY2FsbHkgY2FsbCBhbmQgdXBkYXRlIGF4aXMKICAgICAgY29uc3QgYXhpcyA9IGJpbmRpbmcuYXJnOwogICAgICBjb25zdCBheGlzTWV0aG9kID0geyB4OiAiYXhpc0JvdHRvbSIsIHk6ICJheGlzTGVmdCIgfVtheGlzXTsKICAgICAgY29uc3QgbWV0aG9kQXJnID0gYmluZGluZy52YWx1ZVtheGlzXTsKICAgICAgZDMuc2VsZWN0KGVsKS50cmFuc2l0aW9uKCkuY2FsbChkM1theGlzTWV0aG9kXShtZXRob2RBcmcpLnRpY2tzKDUpKTsKICAgIH0sCiAgfSwKCiAgd2F0Y2g6IHsKICAgIGRhdGFTdGF0ZTogZnVuY3Rpb24obmV3U3RhdGUpIHsKICAgICAgLy9UT0RPOiBCcnVzaCBpcyBub3QgaW5pdGlhbGl6ZWQgd2hlbiB0aGUgc2l6ZSBpcyBpbml0aWFsbHkgbG9hZGVkLiBObyBpZGVhIHdoeS4KICAgICAgaWYobmV3U3RhdGUpIHRoaXMuYnJ1c2goKSAvL2luaXRpYWxpemUgYnJ1c2ggYXMgc29vbiBhcyB5b3UgaGF2ZSBkYXRhCiAgICB9CiAgfSwKCgoKICBtb3VudGVkICgpIHsKICAgIHRoaXMuZ2V0V2lkdGgoKQogICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24oKSB7CiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmdldFdpZHRoKTsKICAgIH0pCiAgfSwKCiAgbWV0aG9kczogewogICAgLy9pbml0aWFsaXplIGJydXNoIChkcmFnYWJsZSBzZWxlY3RvciBmb3IgeC1heGlzKSBhbmQgYWRkIGl0IHRvIERPTQogICAgYnJ1c2g6IGZ1bmN0aW9uKCkgewogICAgICBjb25zdCBicnVzaCA9IGQzLmJydXNoWCgpCiAgICAgICAgLmV4dGVudCh0aGlzLnNjYWxlcy5taWNyb1gucmFuZ2UoKS5tYXAoKGUsaSkgPT4gW2UsaSo1MF0pKSAvL2JydXNoIHdpZHRoIGlzIHJhbmdlIG9mIHNjYWxlLCBoZWlnaHQgaXMgZml4ZWQgYXQgNTAKICAgICAgICAub24oImVuZCIsIHRoaXMudXBkYXRlWCkKICAgICAgICAvLy5vbigiYnJ1c2ggZW5kIiwgdGhpcy51cGRhdGVYKSAvL3VwZGF0ZSBjb250aW5vdXNseSB3aGlsZSBtb3ZpbmcgKHRoaXMgbWF5IHJlc3VsdCBpbiBjcmFwIHBlcmZvcm1hbmNlKQoKICAgICAgZDMuc2VsZWN0KCJnLmJydXNoIikKICAgICAgICAuY2FsbChicnVzaCkKICAgICAgICAuY2FsbChicnVzaC5tb3ZlLCB0aGlzLnNjYWxlcy54LnJhbmdlKCkpCiAgICB9LAogICAgLy9zY2FsZSB4LWF4aXMgb2YgdmlzdWFsaXphdGlvbiB0byBmaXQgYm91bmRhcmllcyBvZiBicnVzaAogICAgdXBkYXRlWDogZnVuY3Rpb24oKSB7CiAgICAgIGxldCBkb21haW4gPSBkMy5ldmVudC5zZWxlY3Rpb24ubWFwKHZhbHVlID0+IHRoaXMuc2NhbGVzLm1pY3JvWC5pbnZlcnQodmFsdWUpKSAvL2dldCBuZXcgZG9tYWluIGJ5IGdldHRpbmcgZWRnZXMgb2Ygb3ZlcmxheSBhbmQgdHJhbnNsYXRlIHRoZW0gdG8gZGF0ZXMKICAgICAgZG9tYWluLmZvckVhY2goKHZhbHVlLGkpID0+IHsKICAgICAgICB0aGlzLiRzZXQodGhpcy54RG9tYWluLGksdmFsdWUpIC8vaXRlcmF0ZSBvdmVyIHRoaXMgYXJyYXkgdG8gdHJpZ2dlciByZWFjdGl2aXR5CiAgICAgIH0pCgogICAgICBkMy5zZWxlY3QoIi54QXhlcyIpLnRyYW5zaXRpb24oKS5jYWxsKGQzLmF4aXNCb3R0b20odGhpcy5zY2FsZXMueCkpIC8vdXBkYXRlIEF4aXMKICAgIH0sCgogICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkgewogICAgICBpZih0aGlzLiRyZWZzLnZpcykgewogICAgICAgIHRoaXMuc3R5bGUud2lkdGggPSB0aGlzLiRyZWZzLnZpcy5jbGllbnRXaWR0aAogICAgICAgIGlmKHRoaXMuZGF0YVN0YXRlKSB7CiAgICAgICAgICB0aGlzLmJydXNoKCkKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICBzaG93VGV4dDogZnVuY3Rpb24oYWN0aXZlLGV2ZW50LGluZGV4KSB7CiAgICAgIHRoaXMuY3VycmVudEV2ZW50ID0gZXZlbnQKICAgICAgaWYoYWN0aXZlKSB7CiAgICAgICAgZDMuc2VsZWN0KCIuZXZlbnQtIitpbmRleCsiIGxpbmUiKS50cmFuc2l0aW9uKCkuYXR0cigic3Ryb2tlLXdpZHRoIiw4KS5hdHRyKCJ4IiwtNCkKICAgICAgfSBlbHNlIHsKICAgICAgICBkMy5zZWxlY3RBbGwoIi5ldmVudHMgbGluZSIpLnRyYW5zaXRpb24oKS5hdHRyKCJzdHJva2Utd2lkdGgiLDIpLmF0dHIoIngiLDApCiAgICAgIH0KCiAgICB9CiAgfQoKCgogIC8qcHJvcHM6IHsKICB9LAoKCgogIGNyZWF0ZWQgKCkgewogIH0sCgogIG1ldGhvZHM6IHsKICB9LCovCn0K"},{"version":3,"sources":["vis.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA","file":"vis.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"col-8\" ref=\"vis\">\n    <svg :width=\"style.width\" :height=\"style.height+style.margin.top + style.margin.bottom\" v-if=\"dataState\" class=\"lines\">\n      <defs>\n        <clipPath id=\"mask\">\n          <rect :x=\"style.margin.left\" y=\"0\" :width=\"style.width\" :height=\"style.height-style.margin.top-style.margin.bottom\" />\n        </clipPath>\n      </defs>\n      <g class=\"axes\" :transform=\"`translate(0,${style.margin.top})`\">\n        <text font-size=\"6pt\" y=\"-10\" :x=\"style.margin.left+10\" text-anchor=\"middle\">{{activeMetric.display}}</text>\n        <g v-axis:x=\"scales\" class=\"xAxes\" :transform=\"`translate(0,${style.height-style.margin.top-style.margin.bottom})`\"></g>\n        <g v-axis:y=\"scales\" class=\"yAxes\" :transform=\"`translate(${style.margin.left},0)`\"></g>\n      </g>\n      <g class=\"events\" v-if=\"showEvents\" clip-path=\"url(#mask)\" :transform=\"`translate(0,${style.margin.top})`\"  >\n        <g v-for=\"(event, index) in events\" :class=\"'event-'+index\" :key=\"`event-${index}`\" :transform=\"`translate(${event.x},0)`\">\n          <line x0=\"0\" :y0=\"style.margin.top\" x1=\"0\" :y1=\"style.height-style.margin.bottom-style.margin.top\" stroke=\"lightgrey\" stroke-width=\"2\" fill=\"lightgrey\" @mouseover=\"showText(true,event,index)\" @mouseout=\"showText(false,{date: '', text: ''},index)\" />\n          <!--<text x=\"10\" opacity=\"0\" :y=\"style.margin.top+20\" style=\"font-weight: bold\">{{event.date}}</text>\n          <text x=\"10\" opacity=\"0\" :y=\"style.margin.top+30\">{{event.text}}</text>-->\n        </g>\n      </g>\n      <!--<g class=\"extremeValues\" v-if=\"dataState\">\n        <g v-for=\"(extremeLine, index) in extremeValues\" v-bind:key=\"'extreme-'+index\">\n          <circle v-for=\"(circle, index) in extremeLine.circles\" :key=\"'circle-'+index\" :cx=\"circle.x\" :cy=\"circle.y\" r=\"10\" fill=\"none\" :stroke=\"extremeLine.color\" stroke-width=\"1\" stroke-dasharray=\"4 1\"/>\n        </g>\n      </g>-->\n\n      <g clip-path=\"url(#mask)\" :transform=\"`translate(0,${style.margin.top})`\">\n        <g class=\"lines\" v-for=\"line in lines\" v-bind:key=\"line.identifier\" >\n          <path v-if=\"line.path\" :d=\"line.path\" :fill=\"line.color\" stroke=\"none\"/>\n        </g>\n      </g>\n      <g class=\"legend\" :transform=\"`translate(${style.width-style.margin.right-50},${style.height-style.margin.bottom-50})`\">\n        <g>\n          <text text-anchor=\"end\">less confident</text>\n          <line x0=\"0\" x1=\"20\" y0=\"0\" y1=\"0\" transform=\"translate(2,-3)\" stroke=\"black\" stroke-width=\"2\"/>\n        </g>\n        <g transform=\"translate(0,10)\">\n          <text text-anchor=\"end\">more confident</text>\n          <line x0=\"0\" x1=\"20\" y0=\"0\" y1=\"0\" transform=\"translate(2,-3)\" stroke=\"black\" stroke-width=\"5\"/>\n        </g>\n      </g>\n    </svg>\n\n    <!--brush for x-axis transformation -->\n    <svg :width=\"style.width\" height=\"50\" style=\"background-color: lightgrey\">\n      <g v-if=\"dataState\">\n        <g class=\"lines\" v-for=\"line in lines\" v-bind:key=\"line.identifier\" >\n          <path v-if=\"line.micro\" :d=\"line.micro\" :stroke=\"line.color\" stroke-opacity=\"0.5\" fill=\"none\"/>\n        </g>\n      </g>\n      <g class=\"brush\" />\n    </svg>\n\n\n    <form>\n      <div class=\"form-check\">\n        <input type=\"checkbox\" class=\"form-check-input\" id=\"exampleCheck1\" v-model=\"showEvents\" @click=\"showEvents = !showEvents\">\n        <label class=\"form-check-label\" for=\"exampleCheck1\">Events:</label>\n      </div>\n    </form>\n    <div class=\"currentEvent\">\n      <span>{{currentEvent.date}}</span>\n      <p>{{currentEvent.text}}</p>\n    </div>\n\n  </div>\n</template>\n\n<script>\nimport * as d3 from 'd3'\n\n//import { regressionLinear } from 'd3-regression';\n\n\nexport default {\n  data() {\n    return {\n      showEvents: true,\n      currentEvent: {},\n      xDomain: [],\n      lineThickness: [3,10],\n      style: {\n        width: 1000, //TODO: set to window width\n        height: 300,\n        margin: {\n          top: 30,\n          right: 25,\n          bottom: 0 ,\n          left: 40\n        }\n      },\n    }\n  },\n\n  computed: {\n    events: { //get additional information from store\n      cache: true,\n      get: function() {\n        let parseTime = d3.timeParse(\"%d-%m-%Y\");\n        let events = this.$store.state.events.map(event => {\n          event.x = this.scales.x(parseTime(event.date)) //translate date to position\n          return event\n        })\n        return events\n      }\n    },\n\n    activeMetric: function() {return this.$store.getters.getActiveMetric},\n\n    //get data from store (this is the computed property \"data\", not vue's data property)\n    data: {\n      cache: false,\n      get: function() {\n        return this.$store.getters.getLines.map(line => {\n          line.touched = 0 //add counter for reactivity when using brush function\n          return line\n        })\n      }\n    },\n\n    //check if every line we received also has data values before we render\n    dataState: function() {\n      let state = false //asume that condition is not met\n      let hasData = this.data.map(line => (line.values) ? true : false) //check if value array exists\n      if(hasData.length > 0 && hasData.every(bool => bool)) state = true //check if all lines have data (and if we have lines at all, otherwise condition for every() would be true)\n      return state\n    },\n\n    //compute scales based on values of all passed lines\n    scales: {\n      cache: true,\n      get() {\n        let parseTime = d3.timeParse(\"%Y-%m\");\n        let style = this.style\n\n        //set range vor all scales on main chart\n        const x = d3.scaleTime().range([style.margin.left,style.width - style.margin.left - style.margin.right]);\n        const y = d3.scaleLinear().range([\n          style.height - style.margin.top - style.margin.bottom,\n          style.margin.bottom\n        ]);\n        const confidence = d3.scaleLinear().range(this.lineThickness)\n\n        //set range vor all scales on brushable micro chart\n        const microX = d3.scaleLinear().range([style.margin.left,style.width - style.margin.left - style.margin.right]);\n        const microY = d3.scaleLinear().range([45,5]);\n\n        //bind scales to axes\n        d3.axisLeft().scale(x);\n        d3.axisBottom().scale(y);\n\n        //get minimum and maximum values for each line (i know, it's not elegant :)\n        if(this.dataState) {\n          let arr = []\n          this.data.forEach(line => {\n            line.values.forEach(value => {\n              arr.push(value)\n            })\n          })\n\n          //if this is the first time, get a the xDomain from data, otherwise it has been set by the brush\n          let domain = (this.xDomain.length > 0) ? this.xDomain : d3.extent(arr, d => parseTime(d.d))\n\n          //set domain of all sccales\n          x.domain(domain);\n          microX.domain(d3.extent(arr, d => parseTime(d.d))); //definitely set this to the maximum data domain so we can push it to the limit\n          y.domain(d3.extent(arr, d => +d.r)).nice();\n          microY.domain(d3.extent(arr, d => +d.r));\n          confidence.domain(d3.extent(arr, d => +d.c))\n        }\n\n        return { x, y, microX, microY, confidence };\n      }\n    },\n\n\n    /*extremeValues: function(){\n      let parseTime = d3.timeParse(\"%Y-%m\");\n      let domain = this.scales.x.domain()\n\n      return this.data.map(line => { //create array for all lines. look in all lines...\n\n        //look for values that are within the visible boundaries of the x-axis\n        let visible = line.values.filter(value => {\n          let date = parseTime(value.d)\n          return (date > domain[0] && date < domain[1]) ? true : false;\n        })\n\n        //form those, get two peaks and two valley values\n        let sorted = visible.sort((a,b) => a.r - b.r)\n        let extreme = sorted.slice(0,2).concat(sorted.slice(sorted.length-2,sorted.length))\n\n        let circles = extreme.map(value => {\n          return {\n            x: this.scales.x(parseTime(value.d)),\n            y: this.scales.y(value.r)\n          }\n        })\n        let obj = {\n          color: line.color,\n          circles: circles\n        }\n        return obj\n      })\n    },*/\n\n\n    //for each line, compute the actual plot\n    lines: {\n      cache: false,\n      get: function() {\n        let parseTime = d3.timeParse(\"%Y-%m\");\n\n        //generator for area for main visualization\n         const path = d3.area()\n         .curve(d3.curveBasis) //make curve smooth\n         .x(d => this.scales.x(parseTime(d.d)))\n         //compute two y-values based on confidence() --> number of reviews that produce the average value\n         .y0(d => this.scales.y(d.r)-this.scales.confidence(d.c))\n         .y1(d => this.scales.y(d.r)+this.scales.confidence(d.c));\n\n         /*const path = d3.line()\n         .x(d => this.scales.x(parseTime(d.d)))\n         .y(d => this.scales.y(d.r));*/\n\n         //generator line for brushable micro visualzation\n         const micro = d3.line()\n         .curve(d3.curveBasis)\n         .x(d => this.scales.microX(parseTime(d.d)))\n         .y(d => this.scales.microY(d.r));\n\n         return this.data.map(line => {\n           if(line.values) {\n             //compute paths based on line values\n             line.path = path(line.values)\n             line.micro = micro(line.values)\n           }\n           return line\n         })\n      }\n    },\n  },\n\n\n\n  directives: {\n    axis(el, binding) {//dynamically call and update axis\n      const axis = binding.arg;\n      const axisMethod = { x: \"axisBottom\", y: \"axisLeft\" }[axis];\n      const methodArg = binding.value[axis];\n      d3.select(el).transition().call(d3[axisMethod](methodArg).ticks(5));\n    },\n  },\n\n  watch: {\n    dataState: function(newState) {\n      //TODO: Brush is not initialized when the size is initially loaded. No idea why.\n      if(newState) this.brush() //initialize brush as soon as you have data\n    }\n  },\n\n\n\n  mounted () {\n    this.getWidth()\n    this.$nextTick(function() {\n      window.addEventListener('resize', this.getWidth);\n    })\n  },\n\n  methods: {\n    //initialize brush (dragable selector for x-axis) and add it to DOM\n    brush: function() {\n      const brush = d3.brushX()\n        .extent(this.scales.microX.range().map((e,i) => [e,i*50])) //brush width is range of scale, height is fixed at 50\n        .on(\"end\", this.updateX)\n        //.on(\"brush end\", this.updateX) //update continously while moving (this may result in crap performance)\n\n      d3.select(\"g.brush\")\n        .call(brush)\n        .call(brush.move, this.scales.x.range())\n    },\n    //scale x-axis of visualization to fit boundaries of brush\n    updateX: function() {\n      let domain = d3.event.selection.map(value => this.scales.microX.invert(value)) //get new domain by getting edges of overlay and translate them to dates\n      domain.forEach((value,i) => {\n        this.$set(this.xDomain,i,value) //iterate over this array to trigger reactivity\n      })\n\n      d3.select(\".xAxes\").transition().call(d3.axisBottom(this.scales.x)) //update Axis\n    },\n\n    getWidth: function() {\n      if(this.$refs.vis) {\n        this.style.width = this.$refs.vis.clientWidth\n        if(this.dataState) {\n          this.brush()\n        }\n      }\n    },\n    showText: function(active,event,index) {\n      this.currentEvent = event\n      if(active) {\n        d3.select(\".event-\"+index+\" line\").transition().attr(\"stroke-width\",8).attr(\"x\",-4)\n      } else {\n        d3.selectAll(\".events line\").transition().attr(\"stroke-width\",2).attr(\"x\",0)\n      }\n\n    }\n  }\n\n\n\n  /*props: {\n  },\n\n\n\n  created () {\n  },\n\n  methods: {\n  },*/\n}\n</script>\n\n<style scoped>\ndiv {\n  background-color: #F7F7F7;\n}\nsvg.lines {\n  margin-top: 50px;\n  background-color: white;\n}\npath {\n  transition: d .3s\n}\n\n.legend {\n  font-size: 6pt;\n}\n\n.currentEvent span {\n  font-size: .8em;\n  font-weight: bold;\n}\n\n.currentEvent text {\n  font-size: 10px;\n}\n</style>\n"]}]}