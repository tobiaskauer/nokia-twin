{"remainingRequest":"/Users/tk/GitHub/nokiatwin/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/tk/GitHub/nokiatwin/src/components/vis.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/tk/GitHub/nokiatwin/src/components/vis.vue","mtime":1607085558048},{"path":"/Users/tk/GitHub/nokiatwin/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/tk/GitHub/nokiatwin/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/tk/GitHub/nokiatwin/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJwppbXBvcnQgeyBWdWVEYXRlUGlja2VyIH0gZnJvbSAnQG1hdGhpZXVzdGFuL3Z1ZS1kYXRlcGlja2VyJzsKaW1wb3J0ICdAbWF0aGlldXN0YW4vdnVlLWRhdGVwaWNrZXIvZGlzdC92dWUtZGF0ZXBpY2tlci5taW4uY3NzJzsKaW1wb3J0ICogYXMgcG5nIGZyb20gJ3NhdmUtc3ZnLWFzLXBuZyc7CgoKZXhwb3J0IGRlZmF1bHQgewogIGNvbXBvbmVudHMgOiB7CiAgICBWdWVEYXRlUGlja2VyLAogIH0sCiAgZGF0YSgpIHsKICAgIHJldHVybiB7CiAgICAgIHNob3dFdmVudHM6IHRydWUsCiAgICAgIGN1cnJlbnRFdmVudDoge30sCiAgICAgIHhEb21haW46IFtdLAogICAgICBkYXRlUGlja2VyOiBbXSwgLy9lbXB0eSBhcnJheSB0byBwYXNzIGRhdGVzIGJldHdlZW4gZGF0ZXBpY2tlciBhbmQgc2NhbGVzCiAgICAgIGJydXNoOiBudWxsLAogICAgICBsaW5lVGhpY2tuZXNzOiBbMyw3XSwKICAgICAgc3R5bGU6IHsKICAgICAgICB3aWR0aDogMTAwMCwgLy9UT0RPOiBzZXQgdG8gd2luZG93IHdpZHRoCiAgICAgICAgaGVpZ2h0OiAzMDAsCiAgICAgICAgbWFyZ2luOiB7CiAgICAgICAgICB0b3A6IDMwLAogICAgICAgICAgcmlnaHQ6IDI1LAogICAgICAgICAgYm90dG9tOiAwICwKICAgICAgICAgIGxlZnQ6IDQwCiAgICAgICAgfQogICAgICB9LAogICAgfQogIH0sCgogIGNvbXB1dGVkOiB7CiAgICBldmVudHM6IHsgLy9nZXQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBmcm9tIHN0b3JlCiAgICAgIGNhY2hlOiB0cnVlLAogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIGxldCBwYXJzZVRpbWUgPSBkMy50aW1lUGFyc2UoIiVkLSVtLSVZIik7CiAgICAgICAgbGV0IGV2ZW50cyA9IHRoaXMuJHN0b3JlLnN0YXRlLmV2ZW50cy5tYXAoZXZlbnQgPT4gewogICAgICAgICAgZXZlbnQueCA9IHRoaXMuc2NhbGVzLngocGFyc2VUaW1lKGV2ZW50LmRhdGUpKSAvL3RyYW5zbGF0ZSBkYXRlIHRvIHBvc2l0aW9uCiAgICAgICAgICByZXR1cm4gZXZlbnQKICAgICAgICB9KQogICAgICAgIHJldHVybiBldmVudHMKICAgICAgfQogICAgfSwKCgogICAgYWN0aXZlTWV0cmljOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5nZXRBY3RpdmVNZXRyaWN9LAoKICAgIC8vZ2V0IGRhdGEgZnJvbSBzdG9yZSAodGhpcyBpcyB0aGUgY29tcHV0ZWQgcHJvcGVydHkgImRhdGEiLCBub3QgdnVlJ3MgZGF0YSBwcm9wZXJ0eSkKICAgIGRhdGE6IHsKICAgICAgY2FjaGU6IGZhbHNlLAogICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzLmdldExpbmVzLm1hcChsaW5lID0+IHsKICAgICAgICAgIGxpbmUudG91Y2hlZCA9IDAgLy9hZGQgY291bnRlciBmb3IgcmVhY3Rpdml0eSB3aGVuIHVzaW5nIGJydXNoIGZ1bmN0aW9uCiAgICAgICAgICByZXR1cm4gbGluZQogICAgICAgIH0pCiAgICAgIH0KICAgIH0sCgogICAgLy9jaGVjayBpZiBldmVyeSBsaW5lIHdlIHJlY2VpdmVkIGFsc28gaGFzIGRhdGEgdmFsdWVzIGJlZm9yZSB3ZSByZW5kZXIKICAgIGRhdGFTdGF0ZTogZnVuY3Rpb24oKSB7CiAgICAgIGxldCBzdGF0ZSA9IGZhbHNlIC8vYXN1bWUgdGhhdCBjb25kaXRpb24gaXMgbm90IG1ldAogICAgICBsZXQgaGFzRGF0YSA9IHRoaXMuZGF0YS5tYXAobGluZSA9PiAobGluZS52YWx1ZXMpID8gdHJ1ZSA6IGZhbHNlKSAvL2NoZWNrIGlmIHZhbHVlIGFycmF5IGV4aXN0cwogICAgICBpZihoYXNEYXRhLmxlbmd0aCA+IDAgJiYgaGFzRGF0YS5ldmVyeShib29sID0+IGJvb2wpKSBzdGF0ZSA9IHRydWUgLy9jaGVjayBpZiBhbGwgbGluZXMgaGF2ZSBkYXRhIChhbmQgaWYgd2UgaGF2ZSBsaW5lcyBhdCBhbGwsIG90aGVyd2lzZSBjb25kaXRpb24gZm9yIGV2ZXJ5KCkgd291bGQgYmUgdHJ1ZSkKICAgICAgcmV0dXJuIHN0YXRlCiAgICB9LAoKICAgIC8vY29tcHV0ZSBzY2FsZXMgYmFzZWQgb24gdmFsdWVzIG9mIGFsbCBwYXNzZWQgbGluZXMKICAgIHNjYWxlczogewogICAgICBjYWNoZTogdHJ1ZSwKICAgICAgZ2V0KCkgewogICAgICAgIGxldCBwYXJzZVRpbWUgPSBkMy50aW1lUGFyc2UodGhpcy4kc3RvcmUuc3RhdGUuZ3JhbnVsYXJpdHkpOwogICAgICAgIGxldCBzdHlsZSA9IHRoaXMuc3R5bGUKCiAgICAgICAgLy9zZXQgcmFuZ2Ugdm9yIGFsbCBzY2FsZXMgb24gbWFpbiBjaGFydAogICAgICAgIGNvbnN0IHggPSBkMy5zY2FsZVRpbWUoKS5yYW5nZShbc3R5bGUubWFyZ2luLmxlZnQsc3R5bGUud2lkdGggLSBzdHlsZS5tYXJnaW4ubGVmdCAtIHN0eWxlLm1hcmdpbi5yaWdodF0pOwogICAgICAgIGNvbnN0IHkgPSBkMy5zY2FsZUxpbmVhcigpLnJhbmdlKFsKICAgICAgICAgIHN0eWxlLmhlaWdodCAtIHN0eWxlLm1hcmdpbi50b3AgLSBzdHlsZS5tYXJnaW4uYm90dG9tLAogICAgICAgICAgc3R5bGUubWFyZ2luLmJvdHRvbQogICAgICAgIF0pOwogICAgICAgIGNvbnN0IGNvbmZpZGVuY2UgPSBkMy5zY2FsZUxpbmVhcigpLnJhbmdlKHRoaXMubGluZVRoaWNrbmVzcykKCiAgICAgICAgLy9zZXQgcmFuZ2Ugdm9yIGFsbCBzY2FsZXMgb24gYnJ1c2hhYmxlIG1pY3JvIGNoYXJ0CiAgICAgICAgY29uc3QgbWljcm9YID0gZDMuc2NhbGVMaW5lYXIoKS5yYW5nZShbc3R5bGUubWFyZ2luLmxlZnQsc3R5bGUud2lkdGggLSBzdHlsZS5tYXJnaW4ubGVmdCAtIHN0eWxlLm1hcmdpbi5yaWdodF0pOwogICAgICAgIGNvbnN0IG1pY3JvWSA9IGQzLnNjYWxlTGluZWFyKCkucmFuZ2UoWzQ1LDVdKTsKCiAgICAgICAgLy9iaW5kIHNjYWxlcyB0byBheGVzCiAgICAgICAgZDMuYXhpc0xlZnQoKS5zY2FsZSh4KTsKICAgICAgICBkMy5heGlzQm90dG9tKCkuc2NhbGUoeSk7CgogICAgICAgIC8vZ2V0IG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzIGZvciBlYWNoIGxpbmUgKGkga25vdywgaXQncyBub3QgZWxlZ2FudCA6KQogICAgICAgIGlmKHRoaXMuZGF0YVN0YXRlKSB7CiAgICAgICAgICBsZXQgYXJyID0gW10KICAgICAgICAgIHRoaXMuZGF0YS5mb3JFYWNoKGxpbmUgPT4gewogICAgICAgICAgICBsaW5lLnZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHsKICAgICAgICAgICAgICBhcnIucHVzaCh2YWx1ZSkKICAgICAgICAgICAgfSkKICAgICAgICAgIH0pCgogICAgICAgICAgLy9pZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lLCBnZXQgYSB0aGUgeERvbWFpbiBmcm9tIGRhdGEsIG90aGVyd2lzZSBpdCBoYXMgYmVlbiBzZXQgYnkgdGhlIGJydXNoCiAgICAgICAgICBsZXQgZG9tYWluID0gKHRoaXMueERvbWFpbi5sZW5ndGggPiAwKSA/IHRoaXMueERvbWFpbiA6IGQzLmV4dGVudChhcnIsIGQgPT4gcGFyc2VUaW1lKGQuZCkpCgoKICAgICAgICAgIGxldCB5RG9tYWluID0gZDMuZXh0ZW50KGFyciwgZCA9PiArZC5yKQogICAgICAgICAgaWYodGhpcy5hY3RpdmVNZXRyaWMubWV0cmljX2xvd19lbmQpIHlEb21haW5bMF0gPSB0aGlzLmFjdGl2ZU1ldHJpYy5tZXRyaWNfbG93X2VuZAogICAgICAgICAgaWYodGhpcy5hY3RpdmVNZXRyaWMubWV0cmljX2hpZ2hfZW5kKSB5RG9tYWluWzFdID0gdGhpcy5hY3RpdmVNZXRyaWMubWV0cmljX2hpZ2hfZW5kCgogICAgICAgICAgLy9zZXQgZG9tYWluIG9mIGFsbCBzY2NhbGVzCiAgICAgICAgICB4LmRvbWFpbihkb21haW4pOwogICAgICAgICAgbWljcm9YLmRvbWFpbihkMy5leHRlbnQoYXJyLCBkID0+IHBhcnNlVGltZShkLmQpKSk7IC8vZGVmaW5pdGVseSBzZXQgdGhpcyB0byB0aGUgbWF4aW11bSBkYXRhIGRvbWFpbiBzbyB3ZSBjYW4gcHVzaCBpdCB0byB0aGUgbGltaXQKICAgICAgICAgIHkuZG9tYWluKHlEb21haW4pLm5pY2UoKTsKICAgICAgICAgIG1pY3JvWS5kb21haW4oeURvbWFpbik7CiAgICAgICAgICBjb25maWRlbmNlLmRvbWFpbihkMy5leHRlbnQoYXJyLCBkID0+ICtkLmMpKQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIHsgeCwgeSwgbWljcm9YLCBtaWNyb1ksIGNvbmZpZGVuY2UgfTsKICAgICAgfQogICAgfSwKCiAgICAvL2ZvciBlYWNoIGxpbmUsIGNvbXB1dGUgdGhlIGFjdHVhbCBwbG90CiAgICBsaW5lczogewogICAgICBjYWNoZTogZmFsc2UsCiAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgbGV0IHBhcnNlVGltZSA9IGQzLnRpbWVQYXJzZSh0aGlzLiRzdG9yZS5zdGF0ZS5ncmFudWxhcml0eSk7CgogICAgICAgIC8vZ2VuZXJhdG9yIGZvciBhcmVhIGZvciBtYWluIHZpc3VhbGl6YXRpb24KICAgICAgICAgY29uc3QgcGF0aCA9IGQzLmFyZWEoKQogICAgICAgICAuY3VydmUoZDMuY3VydmVCYXNpcykgLy9tYWtlIGN1cnZlIHNtb290aAogICAgICAgICAueChkID0+IHRoaXMuc2NhbGVzLngocGFyc2VUaW1lKGQuZCkpKQogICAgICAgICAvL2NvbXB1dGUgdHdvIHktdmFsdWVzIGJhc2VkIG9uIGNvbmZpZGVuY2UoKSAtLT4gbnVtYmVyIG9mIHJldmlld3MgdGhhdCBwcm9kdWNlIHRoZSBhdmVyYWdlIHZhbHVlCiAgICAgICAgIC55MChkID0+IHRoaXMuc2NhbGVzLnkoZC5yKS10aGlzLnNjYWxlcy5jb25maWRlbmNlKGQuYykpCiAgICAgICAgIC55MShkID0+IHRoaXMuc2NhbGVzLnkoZC5yKSt0aGlzLnNjYWxlcy5jb25maWRlbmNlKGQuYykpOwoKICAgICAgICAgLy9nZW5lcmF0b3IgbGluZSBmb3IgYnJ1c2hhYmxlIG1pY3JvIHZpc3VhbHphdGlvbgogICAgICAgICBjb25zdCBtaWNybyA9IGQzLmxpbmUoKQogICAgICAgICAuY3VydmUoZDMuY3VydmVCYXNpcykKICAgICAgICAgLngoZCA9PiB0aGlzLnNjYWxlcy5taWNyb1gocGFyc2VUaW1lKGQuZCkpKQogICAgICAgICAueShkID0+IHRoaXMuc2NhbGVzLm1pY3JvWShkLnIpKTsKCiAgICAgICAgIHJldHVybiB0aGlzLmRhdGEubWFwKGxpbmUgPT4gewogICAgICAgICAgIGlmKGxpbmUudmFsdWVzKSB7CiAgICAgICAgICAgICAvL2NvbXB1dGUgcGF0aHMgYmFzZWQgb24gbGluZSB2YWx1ZXMKICAgICAgICAgICAgIGxpbmUucGF0aCA9IHBhdGgobGluZS52YWx1ZXMpCiAgICAgICAgICAgICBsaW5lLm1pY3JvID0gbWljcm8obGluZS52YWx1ZXMpCiAgICAgICAgICAgfQogICAgICAgICAgIHJldHVybiBsaW5lCiAgICAgICAgIH0pCiAgICAgIH0KICAgIH0sCiAgfSwKCgoKICBkaXJlY3RpdmVzOiB7CiAgICBheGlzKGVsLCBiaW5kaW5nKSB7Ly9keW5hbWljYWxseSBjYWxsIGFuZCB1cGRhdGUgYXhpcwogICAgICBjb25zdCBheGlzID0gYmluZGluZy5hcmc7CiAgICAgIGNvbnN0IGF4aXNNZXRob2QgPSB7IHg6ICJheGlzQm90dG9tIiwgeTogImF4aXNMZWZ0IiB9W2F4aXNdOwogICAgICBjb25zdCBtZXRob2RBcmcgPSBiaW5kaW5nLnZhbHVlW2F4aXNdOwogICAgICBkMy5zZWxlY3QoZWwpLnRyYW5zaXRpb24oKS5jYWxsKGQzW2F4aXNNZXRob2RdKG1ldGhvZEFyZykudGlja3MoNSkpOwogICAgfSwKICB9LAoKICB3YXRjaDogewogICAgZGF0YVN0YXRlOiBmdW5jdGlvbihuZXdTdGF0ZSkgewogICAgICAvL1RPRE86IEJydXNoIGlzIG5vdCBpbml0aWFsaXplZCB3aGVuIHRoZSBzaXplIGlzIGluaXRpYWxseSBsb2FkZWQuIE5vIGlkZWEgd2h5LgogICAgICBpZihuZXdTdGF0ZSkgdGhpcy5pbml0QnJ1c2goKSAvL2luaXRpYWxpemUgYnJ1c2ggYXMgc29vbiBhcyB5b3UgaGF2ZSBkYXRhCiAgICB9LAoKICAgIHNjYWxlczogZnVuY3Rpb24oKSB7CiAgICAgIHRoaXMuZGF0ZVBpY2tlciA9IHRoaXMuc2NhbGVzLnguZG9tYWluKCkKICAgIH0KICB9LAoKCgogIG1vdW50ZWQgKCkgewogICAgdGhpcy5nZXRXaWR0aCgpCiAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbigpIHsKICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuZ2V0V2lkdGgpOwogICAgfSkKICB9LAoKICBtZXRob2RzOiB7CiAgICBwaWNrRGF0ZTogZnVuY3Rpb24oaSkgewogICAgICBsZXQgcGFyc2VUaW1lID0gZDMudGltZVBhcnNlKCIlWS0lbS0lZCIpOyAvL3VzaW5nIGRpZmZlcmVudCB0aW1lZm9ybWF0cywgcmVkbyB3aGVuIHRoaXMgaXMgZXZlciByZWZhY3RvcmVkCiAgICAgIHRoaXMuZGF0ZVBpY2tlcltpXSA9IHBhcnNlVGltZSh0aGlzLmRhdGVQaWNrZXJbaV0pIC8vbWFrZSBzdXJlIGRhdGVzIGZyb20gdGhlIHBpY2tlciBhcmUgRGF0ZXMgYW5kIG5vdCBzdHJpbmdzICh3aHkgdGhlIGhlbGwgZG9lcyB0aGlzIGdpdmUgbWEgc3RyaW5ncyBhbnl3YXkpCgogICAgICB0aGlzLiRzZXQodGhpcy54RG9tYWluLGksdGhpcy5kYXRlUGlja2VyW2ldKSAvL3NldCB4IGF4aXMgZm9yIGJpZyB2aXMKCiAgICAgIGQzLnNlbGVjdCgiZy5icnVzaCIpCiAgICAgICAgLmNhbGwodGhpcy5icnVzaCkKICAgICAgICAuY2FsbCh0aGlzLmJydXNoLm1vdmUsIHRoaXMuZGF0ZVBpY2tlci5tYXAoZGF0ZSA9PiB0aGlzLnNjYWxlcy5taWNyb1goZGF0ZSkpKQogICAgfSwKCiAgICB3cml0ZURhdGVzdG9VUkw6IGZ1bmN0aW9uKGRhdGVzKSB7CiAgICAgIGxldCBmb3JtYXRUaW1lID0gZDMudGltZUZvcm1hdCgiJVktJW0tJWQiKTsKICAgICAgbGV0IHJvdXRlID0gdGhpcy4kcm91dGUucXVlcnkgLy9nZXQgY3VycmVudCB1cmwgcGFyYW1ldGVycyBhcyBvYmplY3QKCiAgICAgIHJvdXRlLnBlcmlvZCA9IGRhdGVzLm1hcChkYXRlID0+IGZvcm1hdFRpbWUoZGF0ZSkpLmpvaW4oIiwiKQoKICAgICAgbGV0IHJvdXRlU3RyaW5nID0gT2JqZWN0LmVudHJpZXMocm91dGUpLm1hcChlID0+IGVuY29kZVVSSUNvbXBvbmVudChlWzBdKSArICI9IiArIGVuY29kZVVSSUNvbXBvbmVudChlWzFdKSkuam9pbigiJiIpIC8vcGFyc2UgYSBzdHJpbmcgZnJvbSB0aGF0IG9iamVjdAogICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7fSxudWxsLHRoaXMuJHJvdXRlLnBhdGggKyAnbm9raWF0d2luLyMvPycgKyByb3V0ZVN0cmluZykgLy93cml0ZSB0aGF0IHRvIFVSTCAoQ0FVVElPTjogdnVlWCBzdG9yZSBhbmQgVVJMIG1pZ2h0IGJlIGluY29uc2lzdGVudCkKCiAgICB9LAoKICAgIHNhdmVQTkc6IGZ1bmN0aW9uKCkgewogICAgICBjb25zb2xlLmxvZyhkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2hhcnQnKSkKICAgICAgcG5nLnNhdmVTdmdBc1BuZyhkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2hhcnQnKSwgJ2NoYXJ0LnBuZycpCiAgICB9LAoKICAgIC8qY2hhbmdlR3JhbnVsYXJpdHk6IGZ1bmN0aW9uKGdyYW51bGFyaXR5KSB7CgogICAgfSovCgoKICAgIC8vaW5pdGlhbGl6ZSBicnVzaCAoZHJhZ2FibGUgc2VsZWN0b3IgZm9yIHgtYXhpcykgYW5kIGFkZCBpdCB0byBET00KICAgIGluaXRCcnVzaDogZnVuY3Rpb24oKSB7CiAgICAgIHRoaXMuYnJ1c2ggPSBkMy5icnVzaFgoKQogICAgICAgIC5leHRlbnQodGhpcy5zY2FsZXMubWljcm9YLnJhbmdlKCkubWFwKChlLGkpID0+IFtlLGkqNTBdKSkgLy9icnVzaCB3aWR0aCBpcyByYW5nZSBvZiBzY2FsZSwgaGVpZ2h0IGlzIGZpeGVkIGF0IDUwCiAgICAgICAgLm9uKCJlbmQiLCB0aGlzLnVwZGF0ZVgpCiAgICAgICAgLy8ub24oImJydXNoIGVuZCIsIHRoaXMudXBkYXRlWCkgLy91cGRhdGUgY29udGlub3VzbHkgd2hpbGUgbW92aW5nICh0aGlzIG1heSByZXN1bHQgaW4gY3JhcCBwZXJmb3JtYW5jZSkKCiAgICAgICAgLy9pZiB1cmwgaGFzIGEgdGltZXBlcmlvZCwgdXNlIGl0CiAgICAgICAgbGV0IHBhcnNlVGltZSA9IGQzLnRpbWVQYXJzZSgiJVktJW0tJWQiKQogICAgICAgIGxldCBicnVzaFByZXNldCA9IHRoaXMuJHJvdXRlLnF1ZXJ5LnBlcmlvZAogICAgICAgICAgPyB0aGlzLiRyb3V0ZS5xdWVyeS5wZXJpb2Quc3BsaXQoIiwiKSAvL3NwbGl0IHN0cmluZyBpbnRvIHR3byBzZXBlcmF0ZSBkYXRlcwogICAgICAgICAgICAgIC5tYXAoZGF0ZSA9PiB0aGlzLnNjYWxlcy5taWNyb1goIC8vc2NhbGUgdGhlbSBhY2NvcmRpbmcgdG8gdGhlIG1heGltdW0gc2NhbGUgZGVmaW5lZCBpbiB0aGUgYnJ1c2gKICAgICAgICAgICAgICAgIHBhcnNlVGltZShkYXRlKSAvL3BhcnNlIHN0cmluZyB0byBkYXRlCiAgICAgICAgICAgICAgKSkKICAgICAgICAgIDogdGhpcy5zY2FsZXMueC5yYW5nZSgpIC8vaWYgcGVyaW9kIGlzIG5vdCBzZXQsIGp1c3QgdXNlIHRoZSBtYXggcmFuZ2UKICAgICAgZDMuc2VsZWN0KCJnLmJydXNoIikKICAgICAgICAuY2FsbCh0aGlzLmJydXNoKQogICAgICAgIC5jYWxsKHRoaXMuYnJ1c2gubW92ZSwgYnJ1c2hQcmVzZXQpCiAgICB9LAoKICAgIC8vc2NhbGUgeC1heGlzIG9mIHZpc3VhbGl6YXRpb24gdG8gZml0IGJvdW5kYXJpZXMgb2YgYnJ1c2gKICAgIHVwZGF0ZVg6IGZ1bmN0aW9uKCkgewogICAgICBsZXQgZG9tYWluID0gZDMuZXZlbnQuc2VsZWN0aW9uLm1hcCh2YWx1ZSA9PiB0aGlzLnNjYWxlcy5taWNyb1guaW52ZXJ0KHZhbHVlKSkgLy9nZXQgbmV3IGRvbWFpbiBieSBnZXR0aW5nIGVkZ2VzIG9mIG92ZXJsYXkgYW5kIHRyYW5zbGF0ZSB0aGVtIHRvIGRhdGVzCiAgICAgIGRvbWFpbi5mb3JFYWNoKCh2YWx1ZSxpKSA9PiB7CiAgICAgICAgdGhpcy4kc2V0KHRoaXMueERvbWFpbixpLHZhbHVlKSAvL2l0ZXJhdGUgb3ZlciB0aGlzIGFycmF5IHRvIHRyaWdnZXIgcmVhY3Rpdml0eQogICAgICB9KQoKICAgICAgZDMuc2VsZWN0KCIueEF4ZXMiKS50cmFuc2l0aW9uKCkuY2FsbChkMy5heGlzQm90dG9tKHRoaXMuc2NhbGVzLngpKSAvL3VwZGF0ZSBBeGlzCiAgICAgIHRoaXMud3JpdGVEYXRlc3RvVVJMKHRoaXMuc2NhbGVzLnguZG9tYWluKCkpCiAgICB9LAoKICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHsKICAgICAgaWYodGhpcy4kcmVmcy52aXMpIHsKICAgICAgICB0aGlzLnN0eWxlLndpZHRoID0gdGhpcy4kcmVmcy52aXMuY2xpZW50V2lkdGgKICAgICAgICBpZih0aGlzLmRhdGFTdGF0ZSkgewogICAgICAgICAgdGhpcy5pbml0QnJ1c2goKQogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgIHNob3dUZXh0OiBmdW5jdGlvbihhY3RpdmUsZXZlbnQsaW5kZXgpIHsKICAgICAgdGhpcy5jdXJyZW50RXZlbnQgPSBldmVudAogICAgICBpZihhY3RpdmUpIHsKICAgICAgICBkMy5zZWxlY3QoIi5ldmVudC0iK2luZGV4KyIgbGluZSIpLnRyYW5zaXRpb24oKS5hdHRyKCJzdHJva2Utd2lkdGgiLDgpLmF0dHIoIngiLC00KQogICAgICB9IGVsc2UgewogICAgICAgIGQzLnNlbGVjdEFsbCgiLmV2ZW50cyBsaW5lIikudHJhbnNpdGlvbigpLmF0dHIoInN0cm9rZS13aWR0aCIsMikuYXR0cigieCIsMCkKICAgICAgfQoKICAgIH0KICB9Cn0K"},{"version":3,"sources":["vis.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4GA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA","file":"vis.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"col-8\" ref=\"vis\" style=\"margin-top: 50px;\">\n    <div class=\"row errors\">\n      <div class=\"col\">\n        <div v-for=\"(line, i) in lines\" :key=\"i\">\n          <div v-if=\"dataState && line.values.length < 1\" class=\"alert alert-danger\" role=\"alert\" style=\"margin-top:10px;\">\n            Line {{(i+1)}} has no data. Maybe too much filters are active.\n          </div>\n        </div>\n        <div v-if=\"!$route.query.table\" class=\"alert alert-danger\" role=\"alert\" style=\"margin-top:10px;\">\n          No table defined\n        </div>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col\">\n        <svg id=\"chart\" :width=\"style.width\" :height=\"style.height+style.margin.top + style.margin.bottom\" v-if=\"dataState\" class=\"lines\">\n\n          <!--SVG mask to hide overflow -->\n          <defs>\n            <clipPath id=\"mask\">\n              <rect :x=\"style.margin.left\" y=\"0\" :width=\"style.width\" :height=\"style.height-style.margin.top-style.margin.bottom\" />\n            </clipPath>\n          </defs>\n\n          <!-- axes -->\n          <g class=\"axes\" :transform=\"`translate(0,${style.margin.top})`\">\n            <text font-size=\"6pt\" y=\"-10\" :x=\"style.margin.left+10\" text-anchor=\"middle\">{{activeMetric.display}}</text>\n            <g v-axis:x=\"scales\" class=\"xAxes\" :transform=\"`translate(0,${style.height-style.margin.top-style.margin.bottom})`\"></g>\n            <g v-axis:y=\"scales\" class=\"yAxes\" :transform=\"`translate(${style.margin.left},0)`\"></g>\n          </g>\n\n          <!--event overlay -->\n          <g class=\"events\" v-if=\"showEvents\" clip-path=\"url(#mask)\" :transform=\"`translate(0,${style.margin.top})`\"  >\n            <g v-for=\"(event, index) in events\" :class=\"'event-'+index\" :key=\"`event-${index}`\" :transform=\"`translate(${event.x},0)`\">\n              <line x0=\"0\" :y0=\"style.margin.top\" x1=\"0\" :y1=\"style.height-style.margin.bottom-style.margin.top\" stroke=\"lightgrey\" stroke-width=\"2\" fill=\"lightgrey\" @mouseover=\"showText(true,event,index)\" @mouseout=\"showText(false,{date: '', text: ''},index)\" />\n            </g>\n          </g>\n\n          <!--lines -->\n          <g clip-path=\"url(#mask)\" :transform=\"`translate(0,${style.margin.top})`\">\n            <g class=\"lines\" v-for=\"line in lines\" v-bind:key=\"line.identifier\" >\n              <path v-if=\"line.path\" :d=\"line.path\" :fill=\"line.color\" stroke=\"none\"/>\n            </g>\n          </g>\n\n          <!-- legend in bottom right corner -->\n          <g class=\"legend\" :transform=\"`translate(${style.width-style.margin.right-50},${style.height-style.margin.bottom-50})`\">\n            <g>\n              <text text-anchor=\"end\">less confident</text>\n              <line x0=\"0\" x1=\"20\" y0=\"0\" y1=\"0\" transform=\"translate(2,-3)\" stroke=\"black\" stroke-width=\"2\"/>\n            </g>\n            <g transform=\"translate(0,10)\">\n              <text text-anchor=\"end\">more confident</text>\n              <line x0=\"0\" x1=\"20\" y0=\"0\" y1=\"0\" transform=\"translate(2,-3)\" stroke=\"black\" stroke-width=\"5\"/>\n            </g>\n          </g>\n        </svg>\n      </div>\n    </div>\n\n    <!--brush for x-axis transformation -->\n    <div class=\"row brush\">\n      <div class=\"col\">\n        <svg :width=\"style.width\" height=\"50\" style=\"background-color: lightgrey\">\n          <g v-if=\"dataState\">\n            <g class=\"lines\" v-for=\"line in lines\" v-bind:key=\"line.identifier\" >\n              <path v-if=\"line.micro\" :d=\"line.micro\" :stroke=\"line.color\" stroke-opacity=\"0.5\" fill=\"none\"/>\n            </g>\n          </g>\n          <g class=\"brush\" />\n        </svg>\n      </div>\n    </div>\n\n    <div class=\"row\" style=\"margin-top: 20px;\">\n      <div class=\"events col-8\">\n        <form>\n          <div class=\"form-check\">\n            <input type=\"checkbox\" class=\"form-check-input\" id=\"exampleCheck1\" v-model=\"showEvents\" @click=\"showEvents = !showEvents\">\n            <label class=\"form-check-label\" for=\"exampleCheck1\">Events:</label>\n          </div>\n        </form>\n        <div class=\"currentEvent\">\n          <span>{{currentEvent.date}}</span>\n          <p v-html=\"currentEvent.event\"></p>\n        </div>\n      </div>\n      <div class=\"col-4 settings\" style=\"border-left: 1px dotted grey; padding-left: 10px;\">\n        <span class=\"pickDescription\">Start: </span><VueDatePicker @onChange=\"pickDate(0)\" v-model=\"datePicker[0]\" />\n        <span class=\"pickDescription\">End: </span><VueDatePicker @onChange=\"pickDate(1)\" v-model=\"datePicker[1]\" />\n        <!--Granularity:\n        <ui>\n          <li @onClick=\"changeGranularity('day')\">Day</li>\n          <li @onClick=\"changeGranularity('week')\">Week</li>\n          <li @onClick=\"changeGranularity('month')\">Month</li>\n          <li @onClick=\"changeGranularity('year')\">Year</li>\n        </ui>-->\n        <button type=\"button\" class=\"btn btn-outline-primary btn-sm\" @click=\"savePNG\">Download PNG</button>\n\n      </div>\n\n    </div>\n  </div>\n</template>\n\n<script>\nimport * as d3 from 'd3'\nimport { VueDatePicker } from '@mathieustan/vue-datepicker';\nimport '@mathieustan/vue-datepicker/dist/vue-datepicker.min.css';\nimport * as png from 'save-svg-as-png';\n\n\nexport default {\n  components : {\n    VueDatePicker,\n  },\n  data() {\n    return {\n      showEvents: true,\n      currentEvent: {},\n      xDomain: [],\n      datePicker: [], //empty array to pass dates between datepicker and scales\n      brush: null,\n      lineThickness: [3,7],\n      style: {\n        width: 1000, //TODO: set to window width\n        height: 300,\n        margin: {\n          top: 30,\n          right: 25,\n          bottom: 0 ,\n          left: 40\n        }\n      },\n    }\n  },\n\n  computed: {\n    events: { //get additional information from store\n      cache: true,\n      get: function() {\n        let parseTime = d3.timeParse(\"%d-%m-%Y\");\n        let events = this.$store.state.events.map(event => {\n          event.x = this.scales.x(parseTime(event.date)) //translate date to position\n          return event\n        })\n        return events\n      }\n    },\n\n\n    activeMetric: function() {return this.$store.getters.getActiveMetric},\n\n    //get data from store (this is the computed property \"data\", not vue's data property)\n    data: {\n      cache: false,\n      get: function() {\n        return this.$store.getters.getLines.map(line => {\n          line.touched = 0 //add counter for reactivity when using brush function\n          return line\n        })\n      }\n    },\n\n    //check if every line we received also has data values before we render\n    dataState: function() {\n      let state = false //asume that condition is not met\n      let hasData = this.data.map(line => (line.values) ? true : false) //check if value array exists\n      if(hasData.length > 0 && hasData.every(bool => bool)) state = true //check if all lines have data (and if we have lines at all, otherwise condition for every() would be true)\n      return state\n    },\n\n    //compute scales based on values of all passed lines\n    scales: {\n      cache: true,\n      get() {\n        let parseTime = d3.timeParse(this.$store.state.granularity);\n        let style = this.style\n\n        //set range vor all scales on main chart\n        const x = d3.scaleTime().range([style.margin.left,style.width - style.margin.left - style.margin.right]);\n        const y = d3.scaleLinear().range([\n          style.height - style.margin.top - style.margin.bottom,\n          style.margin.bottom\n        ]);\n        const confidence = d3.scaleLinear().range(this.lineThickness)\n\n        //set range vor all scales on brushable micro chart\n        const microX = d3.scaleLinear().range([style.margin.left,style.width - style.margin.left - style.margin.right]);\n        const microY = d3.scaleLinear().range([45,5]);\n\n        //bind scales to axes\n        d3.axisLeft().scale(x);\n        d3.axisBottom().scale(y);\n\n        //get minimum and maximum values for each line (i know, it's not elegant :)\n        if(this.dataState) {\n          let arr = []\n          this.data.forEach(line => {\n            line.values.forEach(value => {\n              arr.push(value)\n            })\n          })\n\n          //if this is the first time, get a the xDomain from data, otherwise it has been set by the brush\n          let domain = (this.xDomain.length > 0) ? this.xDomain : d3.extent(arr, d => parseTime(d.d))\n\n\n          let yDomain = d3.extent(arr, d => +d.r)\n          if(this.activeMetric.metric_low_end) yDomain[0] = this.activeMetric.metric_low_end\n          if(this.activeMetric.metric_high_end) yDomain[1] = this.activeMetric.metric_high_end\n\n          //set domain of all sccales\n          x.domain(domain);\n          microX.domain(d3.extent(arr, d => parseTime(d.d))); //definitely set this to the maximum data domain so we can push it to the limit\n          y.domain(yDomain).nice();\n          microY.domain(yDomain);\n          confidence.domain(d3.extent(arr, d => +d.c))\n        }\n\n        return { x, y, microX, microY, confidence };\n      }\n    },\n\n    //for each line, compute the actual plot\n    lines: {\n      cache: false,\n      get: function() {\n        let parseTime = d3.timeParse(this.$store.state.granularity);\n\n        //generator for area for main visualization\n         const path = d3.area()\n         .curve(d3.curveBasis) //make curve smooth\n         .x(d => this.scales.x(parseTime(d.d)))\n         //compute two y-values based on confidence() --> number of reviews that produce the average value\n         .y0(d => this.scales.y(d.r)-this.scales.confidence(d.c))\n         .y1(d => this.scales.y(d.r)+this.scales.confidence(d.c));\n\n         //generator line for brushable micro visualzation\n         const micro = d3.line()\n         .curve(d3.curveBasis)\n         .x(d => this.scales.microX(parseTime(d.d)))\n         .y(d => this.scales.microY(d.r));\n\n         return this.data.map(line => {\n           if(line.values) {\n             //compute paths based on line values\n             line.path = path(line.values)\n             line.micro = micro(line.values)\n           }\n           return line\n         })\n      }\n    },\n  },\n\n\n\n  directives: {\n    axis(el, binding) {//dynamically call and update axis\n      const axis = binding.arg;\n      const axisMethod = { x: \"axisBottom\", y: \"axisLeft\" }[axis];\n      const methodArg = binding.value[axis];\n      d3.select(el).transition().call(d3[axisMethod](methodArg).ticks(5));\n    },\n  },\n\n  watch: {\n    dataState: function(newState) {\n      //TODO: Brush is not initialized when the size is initially loaded. No idea why.\n      if(newState) this.initBrush() //initialize brush as soon as you have data\n    },\n\n    scales: function() {\n      this.datePicker = this.scales.x.domain()\n    }\n  },\n\n\n\n  mounted () {\n    this.getWidth()\n    this.$nextTick(function() {\n      window.addEventListener('resize', this.getWidth);\n    })\n  },\n\n  methods: {\n    pickDate: function(i) {\n      let parseTime = d3.timeParse(\"%Y-%m-%d\"); //using different timeformats, redo when this is ever refactored\n      this.datePicker[i] = parseTime(this.datePicker[i]) //make sure dates from the picker are Dates and not strings (why the hell does this give ma strings anyway)\n\n      this.$set(this.xDomain,i,this.datePicker[i]) //set x axis for big vis\n\n      d3.select(\"g.brush\")\n        .call(this.brush)\n        .call(this.brush.move, this.datePicker.map(date => this.scales.microX(date)))\n    },\n\n    writeDatestoURL: function(dates) {\n      let formatTime = d3.timeFormat(\"%Y-%m-%d\");\n      let route = this.$route.query //get current url parameters as object\n\n      route.period = dates.map(date => formatTime(date)).join(\",\")\n\n      let routeString = Object.entries(route).map(e => encodeURIComponent(e[0]) + \"=\" + encodeURIComponent(e[1])).join(\"&\") //parse a string from that object\n      history.pushState({},null,this.$route.path + 'nokiatwin/#/?' + routeString) //write that to URL (CAUTION: vueX store and URL might be inconsistent)\n\n    },\n\n    savePNG: function() {\n      console.log(document.getElementById('chart'))\n      png.saveSvgAsPng(document.getElementById('chart'), 'chart.png')\n    },\n\n    /*changeGranularity: function(granularity) {\n\n    }*/\n\n\n    //initialize brush (dragable selector for x-axis) and add it to DOM\n    initBrush: function() {\n      this.brush = d3.brushX()\n        .extent(this.scales.microX.range().map((e,i) => [e,i*50])) //brush width is range of scale, height is fixed at 50\n        .on(\"end\", this.updateX)\n        //.on(\"brush end\", this.updateX) //update continously while moving (this may result in crap performance)\n\n        //if url has a timeperiod, use it\n        let parseTime = d3.timeParse(\"%Y-%m-%d\")\n        let brushPreset = this.$route.query.period\n          ? this.$route.query.period.split(\",\") //split string into two seperate dates\n              .map(date => this.scales.microX( //scale them according to the maximum scale defined in the brush\n                parseTime(date) //parse string to date\n              ))\n          : this.scales.x.range() //if period is not set, just use the max range\n      d3.select(\"g.brush\")\n        .call(this.brush)\n        .call(this.brush.move, brushPreset)\n    },\n\n    //scale x-axis of visualization to fit boundaries of brush\n    updateX: function() {\n      let domain = d3.event.selection.map(value => this.scales.microX.invert(value)) //get new domain by getting edges of overlay and translate them to dates\n      domain.forEach((value,i) => {\n        this.$set(this.xDomain,i,value) //iterate over this array to trigger reactivity\n      })\n\n      d3.select(\".xAxes\").transition().call(d3.axisBottom(this.scales.x)) //update Axis\n      this.writeDatestoURL(this.scales.x.domain())\n    },\n\n    getWidth: function() {\n      if(this.$refs.vis) {\n        this.style.width = this.$refs.vis.clientWidth\n        if(this.dataState) {\n          this.initBrush()\n        }\n      }\n    },\n    showText: function(active,event,index) {\n      this.currentEvent = event\n      if(active) {\n        d3.select(\".event-\"+index+\" line\").transition().attr(\"stroke-width\",8).attr(\"x\",-4)\n      } else {\n        d3.selectAll(\".events line\").transition().attr(\"stroke-width\",2).attr(\"x\",0)\n      }\n\n    }\n  }\n}\n</script>\n\n<style scoped>\ndiv {\n  background-color: #F7F7F7;\n}\nsvg.lines {\n  background-color: white;\n}\npath {\n  transition: d .3s\n}\n\n.legend {\n  font-size: 6pt;\n}\n\n\n\n.currentEvent span {\n  font-size: .8em;\n  font-weight: bold;\n}\n\n.pickDescription {\n  float: left;\n  padding: 3px 0;\n  width: 50px;\n}\n\n.currentEvent text {\n  font-size: 10px;\n}\n</style>\n"]}]}